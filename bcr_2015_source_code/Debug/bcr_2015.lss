
bcr_2015.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000862  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  00000862  000008f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000159  00800078  00800078  0000090e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000090e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000001b0  00000000  00000000  0000093e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000011b3  00000000  00000000  00000aee  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000916  00000000  00000000  00001ca1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000ac4  00000000  00000000  000025b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003b0  00000000  00000000  0000307c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000062b  00000000  00000000  0000342c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000b67  00000000  00000000  00003a57  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000148  00000000  00000000  000045be  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *  Author: Vo Huu Tai
 */ 
#include "../inc/hardware_feature.h"

bool bKeyIsPress(uint8_t ucKeyID){
	uint8_t mask = (1<<ucKeyID);
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	//key is pressed when pin = 0;
	if((PIN_KEY & mask) != mask){
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_9>
		_delay_ms(10);
		if((PIN_KEY & mask) != mask){
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 2e 02 	jmp	0x45c	; 0x45c <__vector_11>
			LED_BUG_ON;
  30:	0c 94 5a 02 	jmp	0x4b4	; 0x4b4 <__vector_12>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
			_delay_ms(10);
			while((PIN_KEY&mask)!=mask);//waiting for key is released
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
			LED_BUG_OFF;
			return true;
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		}
	}
	return false;
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
	}	
	vLedCtrl(LED_FAST_BLINK);
	_delay_ms(10000);
	vLedCtrl(LED_SLOW_BLINK);
	_delay_ms(10000);
	vLedCtrl(LED_STARTUP_COMPELETE);
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e6       	ldi	r30, 0x62	; 98
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a8 37       	cpi	r26, 0x78	; 120
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	21 e0       	ldi	r18, 0x01	; 1
  78:	a8 e7       	ldi	r26, 0x78	; 120
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a1 3d       	cpi	r26, 0xD1	; 209
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 a2 02 	call	0x544	; 0x544 <main>
  8a:	0c 94 2f 04 	jmp	0x85e	; 0x85e <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <v_init_debug_via_uart>:
			sUartPacket.length = ptr_rx_buff[1];
			for(uint8_t i = 0; i < sUartPacket.length; i++){
				ptr_command_data[i] = ptr_rx_buff[i+2];
			}
			sUartPacket.data = ptr_command_data;
			sUartPacket.checksum = ptr_rx_buff[sUartPacket.length + 2];
  92:	86 e2       	ldi	r24, 0x26	; 38
  94:	90 e0       	ldi	r25, 0x00	; 0
  96:	0e 94 7e 02 	call	0x4fc	; 0x4fc <uart_init>
  9a:	82 e0       	ldi	r24, 0x02	; 2
  9c:	90 e0       	ldi	r25, 0x00	; 0
				print(" %d",sUartPacket.data[i]);
			}
			print("\nCheck sum: %d",sUartPacket.checksum);
			#endif
		   
			bIsDubugCommandCompelete = true;
  9e:	0e 94 08 03 	call	0x610	; 0x610 <malloc>
  a2:	90 93 c8 01 	sts	0x01C8, r25
		}
		else { //get data
			bIsDubugCommandCompelete = false;
  a6:	80 93 c7 01 	sts	0x01C7, r24
			ptr_rx_buff[index_rx_buf++] = c;			
  aa:	81 e0       	ldi	r24, 0x01	; 1
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	0e 94 08 03 	call	0x610	; 0x610 <malloc>
  b2:	90 93 cc 01 	sts	0x01CC, r25
  b6:	80 93 cb 01 	sts	0x01CB, r24
  ba:	10 92 ca 01 	sts	0x01CA, r1
  be:	10 92 c9 01 	sts	0x01C9, r1
  c2:	08 95       	ret

000000c4 <print>:
  c4:	2f 92       	push	r2
  c6:	3f 92       	push	r3
  c8:	4f 92       	push	r4
  ca:	5f 92       	push	r5
  cc:	6f 92       	push	r6
  ce:	7f 92       	push	r7
  d0:	8f 92       	push	r8
  d2:	9f 92       	push	r9
		}		
	}	
	return false;
}
  d4:	af 92       	push	r10
  d6:	bf 92       	push	r11
  d8:	cf 92       	push	r12
  da:	df 92       	push	r13
}
struct S_UART_PACKET *s_get_command(){
	return &sUartPacket;
}

void print(const char *p, ...){
  dc:	ef 92       	push	r14
  de:	ff 92       	push	r15
  e0:	0f 93       	push	r16
  e2:	1f 93       	push	r17
  e4:	cf 93       	push	r28
  e6:	df 93       	push	r29
  e8:	cd b7       	in	r28, 0x3d	; 61
  ea:	de b7       	in	r29, 0x3e	; 62
  ec:	2b 97       	sbiw	r28, 0x0b	; 11
  ee:	0f b6       	in	r0, 0x3f	; 63
  f0:	f8 94       	cli
  f2:	de bf       	out	0x3e, r29	; 62
  f4:	0f be       	out	0x3f, r0	; 63
  f6:	cd bf       	out	0x3d, r28	; 61
  f8:	fe 01       	movw	r30, r28
  fa:	b0 96       	adiw	r30, 0x20	; 32
  fc:	01 91       	ld	r16, Z+
  fe:	11 91       	ld	r17, Z+
	int formatLen = 0;
	int base;
	int minusF;
	char numStack[11]; 

	va_start(list, p);
 100:	5f 01       	movw	r10, r30
	while (*p) {
 102:	f8 01       	movw	r30, r16
 104:	80 81       	ld	r24, Z
 106:	88 23       	and	r24, r24
 108:	09 f4       	brne	.+2      	; 0x10c <print+0x48>
 10a:	cd c0       	rjmp	.+410    	; 0x2a6 <print+0x1e2>
			case '%':
				zeroPadding = 0;
				if (p[1] == '0') {
					zeroPadding = 1;++p;
				}
				formatLen = 0;
 10c:	81 2c       	mov	r8, r1
 10e:	91 2c       	mov	r9, r1
								}
								} else {
								base = 16; /* FixMe */
							}
							for (digit = 0; digit < sizeof(numStack);) {
								numStack[digit++] = num%base;
 110:	77 24       	eor	r7, r7
 112:	73 94       	inc	r7
 114:	61 2c       	mov	r6, r1
								if (num & 0x80000000) {
									num = -(signed int)num;
									minusF = 1;
								}
								} else {
								base = 16; /* FixMe */
 116:	68 94       	set
 118:	55 24       	eor	r5, r5
 11a:	54 f8       	bld	r5, 4
 11c:	41 2c       	mov	r4, r1
						case 'X':
						case 'x':
							minusF = 0;
							num = va_arg(list, unsigned int);
							if (*p == 'd') {
								base = 10;
 11e:	31 2c       	mov	r3, r1
	int minusF;
	char numStack[11]; 

	va_start(list, p);
	while (*p) {
		switch (*p) {
 120:	85 32       	cpi	r24, 0x25	; 37
 122:	09 f0       	breq	.+2      	; 0x126 <print+0x62>
 124:	b6 c0       	rjmp	.+364    	; 0x292 <print+0x1ce>
			case '%':
				zeroPadding = 0;
				if (p[1] == '0') {
 126:	f8 01       	movw	r30, r16
 128:	81 81       	ldd	r24, Z+1	; 0x01
 12a:	80 33       	cpi	r24, 0x30	; 48
 12c:	29 f4       	brne	.+10     	; 0x138 <print+0x74>
					zeroPadding = 1;++p;
 12e:	0f 5f       	subi	r16, 0xFF	; 255
 130:	1f 4f       	sbci	r17, 0xFF	; 255
 132:	27 2d       	mov	r18, r7
 134:	36 2d       	mov	r19, r6
 136:	02 c0       	rjmp	.+4      	; 0x13c <print+0x78>

	va_start(list, p);
	while (*p) {
		switch (*p) {
			case '%':
				zeroPadding = 0;
 138:	28 2d       	mov	r18, r8
 13a:	39 2d       	mov	r19, r9
				if (p[1] == '0') {
					zeroPadding = 1;++p;
				}
				formatLen = 0;
				while (*++p) {
 13c:	68 01       	movw	r12, r16
 13e:	ff ef       	ldi	r31, 0xFF	; 255
 140:	cf 1a       	sub	r12, r31
 142:	df 0a       	sbc	r13, r31
 144:	f8 01       	movw	r30, r16
 146:	41 81       	ldd	r20, Z+1	; 0x01
 148:	44 23       	and	r20, r20
 14a:	09 f4       	brne	.+2      	; 0x14e <print+0x8a>
 14c:	ac c0       	rjmp	.+344    	; 0x2a6 <print+0x1e2>
			case '%':
				zeroPadding = 0;
				if (p[1] == '0') {
					zeroPadding = 1;++p;
				}
				formatLen = 0;
 14e:	08 2d       	mov	r16, r8
 150:	19 2d       	mov	r17, r9
				while (*++p) {
					switch (*p) {
 152:	43 36       	cpi	r20, 0x63	; 99
 154:	89 f0       	breq	.+34     	; 0x178 <print+0xb4>
 156:	30 f4       	brcc	.+12     	; 0x164 <print+0xa0>
 158:	45 32       	cpi	r20, 0x25	; 37
 15a:	51 f0       	breq	.+20     	; 0x170 <print+0xac>
 15c:	48 35       	cpi	r20, 0x58	; 88
 15e:	09 f0       	breq	.+2      	; 0x162 <print+0x9e>
 160:	7c c0       	rjmp	.+248    	; 0x25a <print+0x196>
 162:	12 c0       	rjmp	.+36     	; 0x188 <print+0xc4>
 164:	44 36       	cpi	r20, 0x64	; 100
 166:	81 f0       	breq	.+32     	; 0x188 <print+0xc4>
 168:	48 37       	cpi	r20, 0x78	; 120
 16a:	09 f0       	breq	.+2      	; 0x16e <print+0xaa>
 16c:	76 c0       	rjmp	.+236    	; 0x25a <print+0x196>
 16e:	0c c0       	rjmp	.+24     	; 0x188 <print+0xc4>
						case '%':
							uart_putc(*p);
 170:	85 e2       	ldi	r24, 0x25	; 37
 172:	0e 94 92 02 	call	0x524	; 0x524 <uart_putc>
							goto NextLoop0;
 176:	90 c0       	rjmp	.+288    	; 0x298 <print+0x1d4>
						case 'c':
							uart_putc(va_arg(list, int));
 178:	f5 01       	movw	r30, r10
 17a:	80 81       	ld	r24, Z
 17c:	f2 e0       	ldi	r31, 0x02	; 2
 17e:	af 0e       	add	r10, r31
 180:	b1 1c       	adc	r11, r1
 182:	0e 94 92 02 	call	0x524	; 0x524 <uart_putc>
							goto NextLoop0;
 186:	88 c0       	rjmp	.+272    	; 0x298 <print+0x1d4>
						case 'd':
						case 'X':
						case 'x':
							minusF = 0;
							num = va_arg(list, unsigned int);
 188:	f5 01       	movw	r30, r10
 18a:	80 81       	ld	r24, Z
 18c:	91 81       	ldd	r25, Z+1	; 0x01
 18e:	52 e0       	ldi	r21, 0x02	; 2
 190:	a5 0e       	add	r10, r21
 192:	b1 1c       	adc	r11, r1
							if (*p == 'd') {
 194:	44 36       	cpi	r20, 0x64	; 100
 196:	19 f4       	brne	.+6      	; 0x19e <print+0xda>
								base = 10;
 198:	4a e0       	ldi	r20, 0x0A	; 10
 19a:	23 2c       	mov	r2, r3
 19c:	02 c0       	rjmp	.+4      	; 0x1a2 <print+0xde>
								if (num & 0x80000000) {
									num = -(signed int)num;
									minusF = 1;
								}
								} else {
								base = 16; /* FixMe */
 19e:	45 2d       	mov	r20, r5
 1a0:	24 2c       	mov	r2, r4
							}
							for (digit = 0; digit < sizeof(numStack);) {
								numStack[digit++] = num%base;
 1a2:	64 2f       	mov	r22, r20
 1a4:	72 2d       	mov	r23, r2
 1a6:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <__udivmodhi4>
 1aa:	89 83       	std	Y+1, r24	; 0x01
								num /= base;
 1ac:	86 2f       	mov	r24, r22
 1ae:	97 2f       	mov	r25, r23
								if (num == 0) break;
 1b0:	00 97       	sbiw	r24, 0x00	; 0
 1b2:	a9 f0       	breq	.+42     	; 0x1de <print+0x11a>
 1b4:	fe 01       	movw	r30, r28
 1b6:	32 96       	adiw	r30, 0x02	; 2
								}
								} else {
								base = 16; /* FixMe */
							}
							for (digit = 0; digit < sizeof(numStack);) {
								numStack[digit++] = num%base;
 1b8:	e7 2c       	mov	r14, r7
 1ba:	f6 2c       	mov	r15, r6
 1bc:	5f ef       	ldi	r21, 0xFF	; 255
 1be:	e5 1a       	sub	r14, r21
 1c0:	f5 0a       	sbc	r15, r21
 1c2:	64 2f       	mov	r22, r20
 1c4:	72 2d       	mov	r23, r2
 1c6:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <__udivmodhi4>
 1ca:	81 93       	st	Z+, r24
								num /= base;
 1cc:	86 2f       	mov	r24, r22
 1ce:	97 2f       	mov	r25, r23
								if (num == 0) break;
 1d0:	00 97       	sbiw	r24, 0x00	; 0
 1d2:	39 f0       	breq	.+14     	; 0x1e2 <print+0x11e>
									minusF = 1;
								}
								} else {
								base = 16; /* FixMe */
							}
							for (digit = 0; digit < sizeof(numStack);) {
 1d4:	5b e0       	ldi	r21, 0x0B	; 11
 1d6:	e5 16       	cp	r14, r21
 1d8:	f1 04       	cpc	r15, r1
 1da:	81 f7       	brne	.-32     	; 0x1bc <print+0xf8>
 1dc:	02 c0       	rjmp	.+4      	; 0x1e2 <print+0x11e>
								numStack[digit++] = num%base;
 1de:	e7 2c       	mov	r14, r7
 1e0:	f6 2c       	mov	r15, r6
								num /= base;
								if (num == 0) break;
							}
							if (minusF) numStack[digit++] = 0x7F;/*FixMe*/
							if (formatLen > digit) {
 1e2:	e0 16       	cp	r14, r16
 1e4:	f1 06       	cpc	r15, r17
 1e6:	b8 f4       	brcc	.+46     	; 0x216 <print+0x152>
								char paddingChar = ' ';
								formatLen -= digit;
 1e8:	0e 19       	sub	r16, r14
 1ea:	1f 09       	sbc	r17, r15
								if (zeroPadding) paddingChar = '0';
 1ec:	23 2b       	or	r18, r19
 1ee:	21 f4       	brne	.+8      	; 0x1f8 <print+0x134>
								num /= base;
								if (num == 0) break;
							}
							if (minusF) numStack[digit++] = 0x7F;/*FixMe*/
							if (formatLen > digit) {
								char paddingChar = ' ';
 1f0:	68 94       	set
 1f2:	22 24       	eor	r2, r2
 1f4:	25 f8       	bld	r2, 5
 1f6:	04 c0       	rjmp	.+8      	; 0x200 <print+0x13c>
								formatLen -= digit;
								if (zeroPadding) paddingChar = '0';
 1f8:	0f 2e       	mov	r0, r31
 1fa:	f0 e3       	ldi	r31, 0x30	; 48
 1fc:	2f 2e       	mov	r2, r31
 1fe:	f0 2d       	mov	r31, r0
								while (formatLen--) {
 200:	01 15       	cp	r16, r1
 202:	11 05       	cpc	r17, r1
 204:	41 f0       	breq	.+16     	; 0x216 <print+0x152>
									uart_putc(paddingChar);
 206:	82 2d       	mov	r24, r2
 208:	0e 94 92 02 	call	0x524	; 0x524 <uart_putc>
 20c:	01 50       	subi	r16, 0x01	; 1
 20e:	11 09       	sbc	r17, r1
							if (minusF) numStack[digit++] = 0x7F;/*FixMe*/
							if (formatLen > digit) {
								char paddingChar = ' ';
								formatLen -= digit;
								if (zeroPadding) paddingChar = '0';
								while (formatLen--) {
 210:	01 15       	cp	r16, r1
 212:	11 05       	cpc	r17, r1
 214:	c1 f7       	brne	.-16     	; 0x206 <print+0x142>
									uart_putc(paddingChar);
								}
							}
							for (i = digit-1; i >= 0; i--) {
 216:	87 01       	movw	r16, r14
 218:	01 50       	subi	r16, 0x01	; 1
 21a:	11 09       	sbc	r17, r1
 21c:	11 23       	and	r17, r17
 21e:	e4 f1       	brlt	.+120    	; 0x298 <print+0x1d4>
 220:	81 e0       	ldi	r24, 0x01	; 1
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	8c 0f       	add	r24, r28
 226:	9d 1f       	adc	r25, r29
 228:	e8 0e       	add	r14, r24
 22a:	f9 1e       	adc	r15, r25
								if (numStack[i] == 0x7F) {
 22c:	f7 01       	movw	r30, r14
 22e:	82 91       	ld	r24, -Z
 230:	7f 01       	movw	r14, r30
 232:	8f 37       	cpi	r24, 0x7F	; 127
 234:	21 f4       	brne	.+8      	; 0x23e <print+0x17a>
									uart_putc('-');
 236:	8d e2       	ldi	r24, 0x2D	; 45
 238:	0e 94 92 02 	call	0x524	; 0x524 <uart_putc>
 23c:	09 c0       	rjmp	.+18     	; 0x250 <print+0x18c>
									} else if (numStack[i] > 9) {
 23e:	8a 30       	cpi	r24, 0x0A	; 10
 240:	20 f0       	brcs	.+8      	; 0x24a <print+0x186>
									uart_putc(numStack[i]-10 + 'A');
 242:	89 5c       	subi	r24, 0xC9	; 201
 244:	0e 94 92 02 	call	0x524	; 0x524 <uart_putc>
 248:	03 c0       	rjmp	.+6      	; 0x250 <print+0x18c>
									} else {
									uart_putc(numStack[i] + '0');
 24a:	80 5d       	subi	r24, 0xD0	; 208
 24c:	0e 94 92 02 	call	0x524	; 0x524 <uart_putc>
								if (zeroPadding) paddingChar = '0';
								while (formatLen--) {
									uart_putc(paddingChar);
								}
							}
							for (i = digit-1; i >= 0; i--) {
 250:	01 50       	subi	r16, 0x01	; 1
 252:	11 09       	sbc	r17, r1
 254:	11 23       	and	r17, r17
 256:	54 f7       	brge	.-44     	; 0x22c <print+0x168>
 258:	1f c0       	rjmp	.+62     	; 0x298 <print+0x1d4>
									uart_putc(numStack[i] + '0');
								}
							}
							goto NextLoop0;
						default:
							if (*p >= '0' && *p <= '9') {
 25a:	80 ed       	ldi	r24, 0xD0	; 208
 25c:	84 0f       	add	r24, r20
 25e:	8a 30       	cpi	r24, 0x0A	; 10
 260:	10 f5       	brcc	.+68     	; 0x2a6 <print+0x1e2>
								formatLen = formatLen*10 + (*p-'0');
 262:	c8 01       	movw	r24, r16
 264:	88 0f       	add	r24, r24
 266:	99 1f       	adc	r25, r25
 268:	00 0f       	add	r16, r16
 26a:	11 1f       	adc	r17, r17
 26c:	00 0f       	add	r16, r16
 26e:	11 1f       	adc	r17, r17
 270:	00 0f       	add	r16, r16
 272:	11 1f       	adc	r17, r17
 274:	08 0f       	add	r16, r24
 276:	19 1f       	adc	r17, r25
 278:	84 2f       	mov	r24, r20
 27a:	90 e0       	ldi	r25, 0x00	; 0
 27c:	c0 97       	sbiw	r24, 0x30	; 48
 27e:	08 0f       	add	r16, r24
 280:	19 1f       	adc	r17, r25
				zeroPadding = 0;
				if (p[1] == '0') {
					zeroPadding = 1;++p;
				}
				formatLen = 0;
				while (*++p) {
 282:	ff ef       	ldi	r31, 0xFF	; 255
 284:	cf 1a       	sub	r12, r31
 286:	df 0a       	sbc	r13, r31
 288:	f6 01       	movw	r30, r12
 28a:	40 81       	ld	r20, Z
 28c:	41 11       	cpse	r20, r1
 28e:	61 cf       	rjmp	.-318    	; 0x152 <print+0x8e>
 290:	0a c0       	rjmp	.+20     	; 0x2a6 <print+0x1e2>
					}
				}
				if (*p == 0) goto EXIT_LABEL;/*Error*/
				break;
			default:
				uart_putc(*p);
 292:	0e 94 92 02 	call	0x524	; 0x524 <uart_putc>
 296:	68 01       	movw	r12, r16
		}
		NextLoop0:
		p++;
 298:	86 01       	movw	r16, r12
 29a:	0f 5f       	subi	r16, 0xFF	; 255
 29c:	1f 4f       	sbci	r17, 0xFF	; 255
	int base;
	int minusF;
	char numStack[11]; 

	va_start(list, p);
	while (*p) {
 29e:	f6 01       	movw	r30, r12
 2a0:	81 81       	ldd	r24, Z+1	; 0x01
 2a2:	81 11       	cpse	r24, r1
 2a4:	3d cf       	rjmp	.-390    	; 0x120 <print+0x5c>
		NextLoop0:
		p++;
	}
	EXIT_LABEL:
	va_end(list);
 2a6:	2b 96       	adiw	r28, 0x0b	; 11
 2a8:	0f b6       	in	r0, 0x3f	; 63
 2aa:	f8 94       	cli
 2ac:	de bf       	out	0x3e, r29	; 62
 2ae:	0f be       	out	0x3f, r0	; 63
 2b0:	cd bf       	out	0x3d, r28	; 61
 2b2:	df 91       	pop	r29
 2b4:	cf 91       	pop	r28
 2b6:	1f 91       	pop	r17
 2b8:	0f 91       	pop	r16
 2ba:	ff 90       	pop	r15
 2bc:	ef 90       	pop	r14
 2be:	df 90       	pop	r13
 2c0:	cf 90       	pop	r12
 2c2:	bf 90       	pop	r11
 2c4:	af 90       	pop	r10
 2c6:	9f 90       	pop	r9
 2c8:	8f 90       	pop	r8
 2ca:	7f 90       	pop	r7
 2cc:	6f 90       	pop	r6
 2ce:	5f 90       	pop	r5
 2d0:	4f 90       	pop	r4
 2d2:	3f 90       	pop	r3
 2d4:	2f 90       	pop	r2
 2d6:	08 95       	ret

000002d8 <vInitTimer0>:
				Normal mode.
				F = 12Mhz
				T = 5.33333us
				=> prescaler = 64
	*/
	TCCR0 = (1 << CS01) | (1<<CS00);
 2d8:	83 e0       	ldi	r24, 0x03	; 3
 2da:	83 bf       	out	0x33, r24	; 51
	TIMSK |= (1 << TOIE0);
 2dc:	89 b7       	in	r24, 0x39	; 57
 2de:	81 60       	ori	r24, 0x01	; 1
 2e0:	89 bf       	out	0x39, r24	; 57
 2e2:	08 95       	ret

000002e4 <vInitTimer1>:
				F = 12Mhz
				T = 15ms
				=> prescaler = 8.
				ICR1 = 15ms / ((1/12Mhz)*8) = 22500	
	*/
	TCCR1A = (1 << WGM11) | (1 << COM1A1) | (1 << COM1B1);
 2e4:	82 ea       	ldi	r24, 0xA2	; 162
 2e6:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
 2e8:	8a e1       	ldi	r24, 0x1A	; 26
 2ea:	8e bd       	out	0x2e, r24	; 46
	ICR1 = 22500;
 2ec:	84 ee       	ldi	r24, 0xE4	; 228
 2ee:	97 e5       	ldi	r25, 0x57	; 87
 2f0:	97 bd       	out	0x27, r25	; 39
 2f2:	86 bd       	out	0x26, r24	; 38
	OCR1B = 2000;
 2f4:	80 ed       	ldi	r24, 0xD0	; 208
 2f6:	97 e0       	ldi	r25, 0x07	; 7
 2f8:	99 bd       	out	0x29, r25	; 41
 2fa:	88 bd       	out	0x28, r24	; 40
 2fc:	08 95       	ret

000002fe <vInitTimer2>:
				Non-inverting: COM2[1:0] = 10
				F = 12Mhz
				T = 5.5ms
				=> prescaler = 256.
	*/
	TCCR2 = (1 << WGM21) | (1 << WGM20) | (1 << COM21) | (1 << CS22) | (1 << CS21);
 2fe:	8e e6       	ldi	r24, 0x6E	; 110
 300:	85 bd       	out	0x25, r24	; 37
	OCR2 = 100;
 302:	84 e6       	ldi	r24, 0x64	; 100
 304:	83 bd       	out	0x23, r24	; 35
 306:	08 95       	ret

00000308 <vInitProgram>:
#include "../inc/hardware_config.h"
#include "../inc/debug.h"

void vInitProgram(){
	//disable local interrupt
	cli();
 308:	f8 94       	cli
	
	//IO initialize
	LED_BUB_INIT;		//Led debug is output
 30a:	bf 9a       	sbi	0x17, 7	; 23
 30c:	c7 9a       	sbi	0x18, 7	; 24
	KEY_INIT;			//Key is input
 30e:	b8 98       	cbi	0x17, 0	; 23
 310:	c0 9a       	sbi	0x18, 0	; 24
 312:	b9 98       	cbi	0x17, 1	; 23
 314:	c1 9a       	sbi	0x18, 1	; 24
 316:	ba 98       	cbi	0x17, 2	; 23
 318:	c2 9a       	sbi	0x18, 2	; 24
	SWITCH_INIT;		//Switch is input
 31a:	a3 98       	cbi	0x14, 3	; 20
 31c:	ab 9a       	sbi	0x15, 3	; 21
 31e:	a2 98       	cbi	0x14, 2	; 20
 320:	aa 9a       	sbi	0x15, 2	; 21
 322:	a1 98       	cbi	0x14, 1	; 20
 324:	a9 9a       	sbi	0x15, 1	; 21
 326:	a0 98       	cbi	0x14, 0	; 20
 328:	a8 9a       	sbi	0x15, 0	; 21
	MOTOR_LEFT_INIT;
 32a:	bc 9a       	sbi	0x17, 4	; 23
 32c:	be 9a       	sbi	0x17, 6	; 23
 32e:	c6 9a       	sbi	0x18, 6	; 24
 330:	8c 9a       	sbi	0x11, 4	; 17
	MOTOR_RIGHT_INIT;
 332:	bb 9a       	sbi	0x17, 3	; 23
 334:	bd 9a       	sbi	0x17, 5	; 23
 336:	c5 9a       	sbi	0x18, 5	; 24
 338:	8f 9a       	sbi	0x11, 7	; 17
	SLAVE_ENABLE_INIT;
 33a:	a4 9a       	sbi	0x14, 4	; 20
	SLAVE_ON;
 33c:	ac 9a       	sbi	0x15, 4	; 21
	
	//Timer and PWM
	vInitTimer0();
 33e:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <vInitTimer0>
	vInitTimer1();
 342:	0e 94 72 01 	call	0x2e4	; 0x2e4 <vInitTimer1>
	vInitTimer2();	
 346:	0e 94 7f 01 	call	0x2fe	; 0x2fe <vInitTimer2>
	
	//SERIAL
	v_init_debug_via_uart();
 34a:	0e 94 49 00 	call	0x92	; 0x92 <v_init_debug_via_uart>
	//enable local interrupt
	sei();
 34e:	78 94       	sei
 350:	08 95       	ret

00000352 <vPeriodicDec>:
	@param:		none
	@return:	none 
*/

void vPeriodicDec(){	
	if(uigLedPeriodic == 0 ){
 352:	80 91 68 00 	lds	r24, 0x0068
 356:	90 91 69 00 	lds	r25, 0x0069
 35a:	89 2b       	or	r24, r25
 35c:	39 f4       	brne	.+14     	; 0x36c <vPeriodicDec+0x1a>
		uigLedPeriodic = NO_LIMIT;
 35e:	8f ef       	ldi	r24, 0xFF	; 255
 360:	9f ef       	ldi	r25, 0xFF	; 255
 362:	90 93 69 00 	sts	0x0069, r25
 366:	80 93 68 00 	sts	0x0068, r24
 36a:	08 95       	ret
	}else
	uigLedPeriodic--;	
 36c:	80 91 68 00 	lds	r24, 0x0068
 370:	90 91 69 00 	lds	r25, 0x0069
 374:	01 97       	sbiw	r24, 0x01	; 1
 376:	90 93 69 00 	sts	0x0069, r25
 37a:	80 93 68 00 	sts	0x0068, r24
 37e:	08 95       	ret

00000380 <vIntervalDec>:
	@param:		none
	@return:	none 
*/
void vIntervalDec(){
	
	if(uigLedInterval == 0){
 380:	80 91 66 00 	lds	r24, 0x0066
 384:	90 91 67 00 	lds	r25, 0x0067
 388:	89 2b       	or	r24, r25
 38a:	39 f4       	brne	.+14     	; 0x39a <vIntervalDec+0x1a>
		uigLedInterval = NO_LIMIT;
 38c:	8f ef       	ldi	r24, 0xFF	; 255
 38e:	9f ef       	ldi	r25, 0xFF	; 255
 390:	90 93 67 00 	sts	0x0067, r25
 394:	80 93 66 00 	sts	0x0066, r24
 398:	08 95       	ret
	}
	else
	uigLedInterval--;	
 39a:	80 91 66 00 	lds	r24, 0x0066
 39e:	90 91 67 00 	lds	r25, 0x0067
 3a2:	01 97       	sbiw	r24, 0x01	; 1
 3a4:	90 93 67 00 	sts	0x0067, r25
 3a8:	80 93 66 00 	sts	0x0066, r24
 3ac:	08 95       	ret

000003ae <ucPareLedEvent>:
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
	switch(led_event){
 3ae:	82 30       	cpi	r24, 0x02	; 2
 3b0:	69 f0       	breq	.+26     	; 0x3cc <ucPareLedEvent+0x1e>
 3b2:	83 30       	cpi	r24, 0x03	; 3
 3b4:	a1 f0       	breq	.+40     	; 0x3de <ucPareLedEvent+0x30>
 3b6:	81 30       	cpi	r24, 0x01	; 1
 3b8:	d9 f4       	brne	.+54     	; 0x3f0 <ucPareLedEvent+0x42>
		case LED_FAST_BLINK:			
			uigLedInterval = LED_50_MS;			
 3ba:	85 e0       	ldi	r24, 0x05	; 5
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	90 93 67 00 	sts	0x0067, r25
 3c2:	80 93 66 00 	sts	0x0066, r24
	@brief:		parse control for led
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
 3c6:	8f ef       	ldi	r24, 0xFF	; 255
 3c8:	9f ef       	ldi	r25, 0xFF	; 255
	switch(led_event){
		case LED_FAST_BLINK:			
			uigLedInterval = LED_50_MS;			
			break;
 3ca:	08 95       	ret
		case LED_SLOW_BLINK:			
			uigLedInterval = LED_100_MS;			
 3cc:	8a e0       	ldi	r24, 0x0A	; 10
 3ce:	90 e0       	ldi	r25, 0x00	; 0
 3d0:	90 93 67 00 	sts	0x0067, r25
 3d4:	80 93 66 00 	sts	0x0066, r24
	@brief:		parse control for led
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
 3d8:	8f ef       	ldi	r24, 0xFF	; 255
 3da:	9f ef       	ldi	r25, 0xFF	; 255
		case LED_FAST_BLINK:			
			uigLedInterval = LED_50_MS;			
			break;
		case LED_SLOW_BLINK:			
			uigLedInterval = LED_100_MS;			
			break;
 3dc:	08 95       	ret
		case LED_STARTUP_COMPELETE:			
			uigLedInterval = LED_50_MS;	
 3de:	85 e0       	ldi	r24, 0x05	; 5
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	90 93 67 00 	sts	0x0067, r25
 3e6:	80 93 66 00 	sts	0x0066, r24
			uiRet = LED_10_S;	
 3ea:	88 ee       	ldi	r24, 0xE8	; 232
 3ec:	93 e0       	ldi	r25, 0x03	; 3
			break;		
 3ee:	08 95       	ret
	@brief:		parse control for led
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
 3f0:	8f ef       	ldi	r24, 0xFF	; 255
 3f2:	9f ef       	ldi	r25, 0xFF	; 255
			break;		
		default:			
			break;
	}
	return uiRet;
}
 3f4:	08 95       	ret

000003f6 <vLedFlash>:
//
void vLedFlash(){
 3f6:	cf 93       	push	r28
	uint8_t ucStateTemp = ucgLedState;	
 3f8:	c0 91 7a 00 	lds	r28, 0x007A
	
	switch(ucStateTemp){
 3fc:	cc 23       	and	r28, r28
 3fe:	61 f1       	breq	.+88     	; 0x458 <vLedFlash+0x62>
 400:	c1 30       	cpi	r28, 0x01	; 1
 402:	41 f5       	brne	.+80     	; 0x454 <vLedFlash+0x5e>
		case LED_STATE_NONE:	//State NONE do nothing.
			return;
		case LED_STATE_BLINK:		
			vPeriodicDec();
 404:	0e 94 a9 01 	call	0x352	; 0x352 <vPeriodicDec>
			if(uigLedPeriodic == 0){
 408:	80 91 68 00 	lds	r24, 0x0068
 40c:	90 91 69 00 	lds	r25, 0x0069
 410:	89 2b       	or	r24, r25
 412:	29 f4       	brne	.+10     	; 0x41e <vLedFlash+0x28>
				LED_BUG_OFF; //turn off led
 414:	c7 9a       	sbi	0x18, 7	; 24
				bgLedFlag = LED_FLAG_OFF;//set flag is off
 416:	10 92 79 00 	sts	0x0079, r1
				ucStateTemp = LED_STATE_NONE;
 41a:	c0 e0       	ldi	r28, 0x00	; 0
 41c:	1b c0       	rjmp	.+54     	; 0x454 <vLedFlash+0x5e>
			}
			else{
				vIntervalDec();
 41e:	0e 94 c0 01 	call	0x380	; 0x380 <vIntervalDec>
				if(uigLedInterval == 0){
 422:	80 91 66 00 	lds	r24, 0x0066
 426:	90 91 67 00 	lds	r25, 0x0067
 42a:	89 2b       	or	r24, r25
 42c:	99 f4       	brne	.+38     	; 0x454 <vLedFlash+0x5e>
					switch (bgLedFlag)
 42e:	80 91 79 00 	lds	r24, 0x0079
 432:	90 e0       	ldi	r25, 0x00	; 0
 434:	00 97       	sbiw	r24, 0x00	; 0
 436:	31 f0       	breq	.+12     	; 0x444 <vLedFlash+0x4e>
 438:	01 97       	sbiw	r24, 0x01	; 1
 43a:	41 f4       	brne	.+16     	; 0x44c <vLedFlash+0x56>
					{
						case LED_FLAG_ON:
							bgLedFlag = LED_FLAG_OFF;
 43c:	10 92 79 00 	sts	0x0079, r1
							LED_BUG_OFF;
 440:	c7 9a       	sbi	0x18, 7	; 24
							break;
 442:	04 c0       	rjmp	.+8      	; 0x44c <vLedFlash+0x56>
						case LED_FLAG_OFF:
							bgLedFlag = LED_FLAG_ON;
 444:	81 e0       	ldi	r24, 0x01	; 1
 446:	80 93 79 00 	sts	0x0079, r24
							LED_BUG_ON;
 44a:	c7 98       	cbi	0x18, 7	; 24
							break;
						default:							
							break;
					}					
					ucPareLedEvent(ucLedEvent);					
 44c:	80 91 78 00 	lds	r24, 0x0078
 450:	0e 94 d7 01 	call	0x3ae	; 0x3ae <ucPareLedEvent>
			}
			break;
		default:			
			break;		
	}		
	ucgLedState = ucStateTemp;		
 454:	c0 93 7a 00 	sts	0x007A, r28
}
 458:	cf 91       	pop	r28
 45a:	08 95       	ret

0000045c <__vector_11>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
 45c:	1f 92       	push	r1
 45e:	0f 92       	push	r0
 460:	0f b6       	in	r0, 0x3f	; 63
 462:	0f 92       	push	r0
 464:	11 24       	eor	r1, r1
 466:	2f 93       	push	r18
 468:	8f 93       	push	r24
 46a:	9f 93       	push	r25
 46c:	ef 93       	push	r30
 46e:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
 470:	8b b1       	in	r24, 0x0b	; 11
    data = UART0_DATA;
 472:	2c b1       	in	r18, 0x0c	; 12
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 474:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 476:	e0 91 7d 00 	lds	r30, 0x007D
 47a:	ef 5f       	subi	r30, 0xFF	; 255
 47c:	ef 73       	andi	r30, 0x3F	; 63
    
    if ( tmphead == UART_RxTail ) {
 47e:	90 91 7c 00 	lds	r25, 0x007C
 482:	e9 17       	cp	r30, r25
 484:	39 f0       	breq	.+14     	; 0x494 <__stack+0x35>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
 486:	e0 93 7d 00 	sts	0x007D, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
 48a:	f0 e0       	ldi	r31, 0x00	; 0
 48c:	e0 58       	subi	r30, 0x80	; 128
 48e:	ff 4f       	sbci	r31, 0xFF	; 255
 490:	20 83       	st	Z, r18
 492:	01 c0       	rjmp	.+2      	; 0x496 <__stack+0x37>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
 494:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
 496:	90 91 7b 00 	lds	r25, 0x007B
 49a:	89 2b       	or	r24, r25
 49c:	80 93 7b 00 	sts	0x007B, r24
}
 4a0:	ff 91       	pop	r31
 4a2:	ef 91       	pop	r30
 4a4:	9f 91       	pop	r25
 4a6:	8f 91       	pop	r24
 4a8:	2f 91       	pop	r18
 4aa:	0f 90       	pop	r0
 4ac:	0f be       	out	0x3f, r0	; 63
 4ae:	0f 90       	pop	r0
 4b0:	1f 90       	pop	r1
 4b2:	18 95       	reti

000004b4 <__vector_12>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
 4b4:	1f 92       	push	r1
 4b6:	0f 92       	push	r0
 4b8:	0f b6       	in	r0, 0x3f	; 63
 4ba:	0f 92       	push	r0
 4bc:	11 24       	eor	r1, r1
 4be:	8f 93       	push	r24
 4c0:	9f 93       	push	r25
 4c2:	ef 93       	push	r30
 4c4:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
 4c6:	90 91 7f 00 	lds	r25, 0x007F
 4ca:	80 91 7e 00 	lds	r24, 0x007E
 4ce:	98 17       	cp	r25, r24
 4d0:	59 f0       	breq	.+22     	; 0x4e8 <__vector_12+0x34>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 4d2:	e0 91 7e 00 	lds	r30, 0x007E
 4d6:	ef 5f       	subi	r30, 0xFF	; 255
        UART_TxTail = tmptail;
 4d8:	e0 93 7e 00 	sts	0x007E, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 4dc:	f0 e0       	ldi	r31, 0x00	; 0
 4de:	e0 54       	subi	r30, 0x40	; 64
 4e0:	ff 4f       	sbci	r31, 0xFF	; 255
 4e2:	80 81       	ld	r24, Z
 4e4:	8c b9       	out	0x0c, r24	; 12
 4e6:	01 c0       	rjmp	.+2      	; 0x4ea <__vector_12+0x36>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
 4e8:	55 98       	cbi	0x0a, 5	; 10
    }
}
 4ea:	ff 91       	pop	r31
 4ec:	ef 91       	pop	r30
 4ee:	9f 91       	pop	r25
 4f0:	8f 91       	pop	r24
 4f2:	0f 90       	pop	r0
 4f4:	0f be       	out	0x3f, r0	; 63
 4f6:	0f 90       	pop	r0
 4f8:	1f 90       	pop	r1
 4fa:	18 95       	reti

000004fc <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
 4fc:	10 92 7f 00 	sts	0x007F, r1
    UART_TxTail = 0;
 500:	10 92 7e 00 	sts	0x007E, r1
    UART_RxHead = 0;
 504:	10 92 7d 00 	sts	0x007D, r1
    UART_RxTail = 0;
 508:	10 92 7c 00 	sts	0x007C, r1
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
 50c:	99 23       	and	r25, r25
 50e:	1c f4       	brge	.+6      	; 0x516 <uart_init+0x1a>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 510:	22 e0       	ldi	r18, 0x02	; 2
 512:	2b b9       	out	0x0b, r18	; 11
    	 baudrate &= ~0x8000;
 514:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
 516:	90 bd       	out	0x20, r25	; 32
    UBRRL = (unsigned char) baudrate;
 518:	89 b9       	out	0x09, r24	; 9
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 51a:	88 e9       	ldi	r24, 0x98	; 152
 51c:	8a b9       	out	0x0a, r24	; 10
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
 51e:	86 e8       	ldi	r24, 0x86	; 134
 520:	80 bd       	out	0x20, r24	; 32
 522:	08 95       	ret

00000524 <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 524:	20 91 7f 00 	lds	r18, 0x007F
 528:	2f 5f       	subi	r18, 0xFF	; 255
    
    while ( tmphead == UART_TxTail ){
 52a:	90 91 7e 00 	lds	r25, 0x007E
 52e:	29 17       	cp	r18, r25
 530:	e1 f3       	breq	.-8      	; 0x52a <uart_putc+0x6>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
 532:	e2 2f       	mov	r30, r18
 534:	f0 e0       	ldi	r31, 0x00	; 0
 536:	e0 54       	subi	r30, 0x40	; 64
 538:	ff 4f       	sbci	r31, 0xFF	; 255
 53a:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
 53c:	20 93 7f 00 	sts	0x007F, r18

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
 540:	55 9a       	sbi	0x0a, 5	; 10
 542:	08 95       	ret

00000544 <main>:
#include "../lib/inc/debug.h"
//#define UNIT_TEST

int main(void)
{
	vInitProgram();	
 544:	0e 94 84 01 	call	0x308	; 0x308 <vInitProgram>
    while(1)
    {
        #ifdef UNIT_TEST
		vUnitTest();
		#endif // UNIT_TEST		
		print("Hello: 0x%x\n",12);
 548:	1c e0       	ldi	r17, 0x0C	; 12
 54a:	ca e6       	ldi	r28, 0x6A	; 106
 54c:	d0 e0       	ldi	r29, 0x00	; 0
 54e:	1f 92       	push	r1
 550:	1f 93       	push	r17
 552:	df 93       	push	r29
 554:	cf 93       	push	r28
 556:	0e 94 62 00 	call	0xc4	; 0xc4 <print>
 55a:	9f ef       	ldi	r25, 0xFF	; 255
 55c:	23 ed       	ldi	r18, 0xD3	; 211
 55e:	80 e3       	ldi	r24, 0x30	; 48
 560:	91 50       	subi	r25, 0x01	; 1
 562:	20 40       	sbci	r18, 0x00	; 0
 564:	80 40       	sbci	r24, 0x00	; 0
 566:	e1 f7       	brne	.-8      	; 0x560 <main+0x1c>
 568:	00 c0       	rjmp	.+0      	; 0x56a <main+0x26>
 56a:	00 00       	nop
 56c:	0f 90       	pop	r0
 56e:	0f 90       	pop	r0
 570:	0f 90       	pop	r0
 572:	0f 90       	pop	r0
 574:	ec cf       	rjmp	.-40     	; 0x54e <main+0xa>

00000576 <__vector_9>:
		
    }
}
volatile uint16_t uiTimer0Cnt = 0;
ISR(TIMER0_OVF_vect)
{
 576:	1f 92       	push	r1
 578:	0f 92       	push	r0
 57a:	0f b6       	in	r0, 0x3f	; 63
 57c:	0f 92       	push	r0
 57e:	11 24       	eor	r1, r1
 580:	2f 93       	push	r18
 582:	3f 93       	push	r19
 584:	4f 93       	push	r20
 586:	5f 93       	push	r21
 588:	6f 93       	push	r22
 58a:	7f 93       	push	r23
 58c:	8f 93       	push	r24
 58e:	9f 93       	push	r25
 590:	af 93       	push	r26
 592:	bf 93       	push	r27
 594:	ef 93       	push	r30
 596:	ff 93       	push	r31
	TCNT0 = 68;	//~1ms
 598:	84 e4       	ldi	r24, 0x44	; 68
 59a:	82 bf       	out	0x32, r24	; 50
	uiTimer0Cnt++;
 59c:	80 91 c0 01 	lds	r24, 0x01C0
 5a0:	90 91 c1 01 	lds	r25, 0x01C1
 5a4:	01 96       	adiw	r24, 0x01	; 1
 5a6:	90 93 c1 01 	sts	0x01C1, r25
 5aa:	80 93 c0 01 	sts	0x01C0, r24
	if(uiTimer0Cnt == 10){//10ms
 5ae:	80 91 c0 01 	lds	r24, 0x01C0
 5b2:	90 91 c1 01 	lds	r25, 0x01C1
 5b6:	0a 97       	sbiw	r24, 0x0a	; 10
 5b8:	31 f4       	brne	.+12     	; 0x5c6 <__vector_9+0x50>
		uiTimer0Cnt = 0;
 5ba:	10 92 c1 01 	sts	0x01C1, r1
 5be:	10 92 c0 01 	sts	0x01C0, r1
		vLedFlash();
 5c2:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <vLedFlash>
	}
	
 5c6:	ff 91       	pop	r31
 5c8:	ef 91       	pop	r30
 5ca:	bf 91       	pop	r27
 5cc:	af 91       	pop	r26
 5ce:	9f 91       	pop	r25
 5d0:	8f 91       	pop	r24
 5d2:	7f 91       	pop	r23
 5d4:	6f 91       	pop	r22
 5d6:	5f 91       	pop	r21
 5d8:	4f 91       	pop	r20
 5da:	3f 91       	pop	r19
 5dc:	2f 91       	pop	r18
 5de:	0f 90       	pop	r0
 5e0:	0f be       	out	0x3f, r0	; 63
 5e2:	0f 90       	pop	r0
 5e4:	1f 90       	pop	r1
 5e6:	18 95       	reti

000005e8 <__udivmodhi4>:
 5e8:	aa 1b       	sub	r26, r26
 5ea:	bb 1b       	sub	r27, r27
 5ec:	51 e1       	ldi	r21, 0x11	; 17
 5ee:	07 c0       	rjmp	.+14     	; 0x5fe <__udivmodhi4_ep>

000005f0 <__udivmodhi4_loop>:
 5f0:	aa 1f       	adc	r26, r26
 5f2:	bb 1f       	adc	r27, r27
 5f4:	a6 17       	cp	r26, r22
 5f6:	b7 07       	cpc	r27, r23
 5f8:	10 f0       	brcs	.+4      	; 0x5fe <__udivmodhi4_ep>
 5fa:	a6 1b       	sub	r26, r22
 5fc:	b7 0b       	sbc	r27, r23

000005fe <__udivmodhi4_ep>:
 5fe:	88 1f       	adc	r24, r24
 600:	99 1f       	adc	r25, r25
 602:	5a 95       	dec	r21
 604:	a9 f7       	brne	.-22     	; 0x5f0 <__udivmodhi4_loop>
 606:	80 95       	com	r24
 608:	90 95       	com	r25
 60a:	bc 01       	movw	r22, r24
 60c:	cd 01       	movw	r24, r26
 60e:	08 95       	ret

00000610 <malloc>:
 610:	cf 93       	push	r28
 612:	df 93       	push	r29
 614:	82 30       	cpi	r24, 0x02	; 2
 616:	91 05       	cpc	r25, r1
 618:	10 f4       	brcc	.+4      	; 0x61e <malloc+0xe>
 61a:	82 e0       	ldi	r24, 0x02	; 2
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	e0 91 cf 01 	lds	r30, 0x01CF
 622:	f0 91 d0 01 	lds	r31, 0x01D0
 626:	20 e0       	ldi	r18, 0x00	; 0
 628:	30 e0       	ldi	r19, 0x00	; 0
 62a:	a0 e0       	ldi	r26, 0x00	; 0
 62c:	b0 e0       	ldi	r27, 0x00	; 0
 62e:	30 97       	sbiw	r30, 0x00	; 0
 630:	39 f1       	breq	.+78     	; 0x680 <malloc+0x70>
 632:	40 81       	ld	r20, Z
 634:	51 81       	ldd	r21, Z+1	; 0x01
 636:	48 17       	cp	r20, r24
 638:	59 07       	cpc	r21, r25
 63a:	b8 f0       	brcs	.+46     	; 0x66a <malloc+0x5a>
 63c:	48 17       	cp	r20, r24
 63e:	59 07       	cpc	r21, r25
 640:	71 f4       	brne	.+28     	; 0x65e <malloc+0x4e>
 642:	82 81       	ldd	r24, Z+2	; 0x02
 644:	93 81       	ldd	r25, Z+3	; 0x03
 646:	10 97       	sbiw	r26, 0x00	; 0
 648:	29 f0       	breq	.+10     	; 0x654 <malloc+0x44>
 64a:	13 96       	adiw	r26, 0x03	; 3
 64c:	9c 93       	st	X, r25
 64e:	8e 93       	st	-X, r24
 650:	12 97       	sbiw	r26, 0x02	; 2
 652:	2c c0       	rjmp	.+88     	; 0x6ac <malloc+0x9c>
 654:	90 93 d0 01 	sts	0x01D0, r25
 658:	80 93 cf 01 	sts	0x01CF, r24
 65c:	27 c0       	rjmp	.+78     	; 0x6ac <malloc+0x9c>
 65e:	21 15       	cp	r18, r1
 660:	31 05       	cpc	r19, r1
 662:	31 f0       	breq	.+12     	; 0x670 <malloc+0x60>
 664:	42 17       	cp	r20, r18
 666:	53 07       	cpc	r21, r19
 668:	18 f0       	brcs	.+6      	; 0x670 <malloc+0x60>
 66a:	a9 01       	movw	r20, r18
 66c:	db 01       	movw	r26, r22
 66e:	01 c0       	rjmp	.+2      	; 0x672 <malloc+0x62>
 670:	ef 01       	movw	r28, r30
 672:	9a 01       	movw	r18, r20
 674:	bd 01       	movw	r22, r26
 676:	df 01       	movw	r26, r30
 678:	02 80       	ldd	r0, Z+2	; 0x02
 67a:	f3 81       	ldd	r31, Z+3	; 0x03
 67c:	e0 2d       	mov	r30, r0
 67e:	d7 cf       	rjmp	.-82     	; 0x62e <malloc+0x1e>
 680:	21 15       	cp	r18, r1
 682:	31 05       	cpc	r19, r1
 684:	f9 f0       	breq	.+62     	; 0x6c4 <malloc+0xb4>
 686:	28 1b       	sub	r18, r24
 688:	39 0b       	sbc	r19, r25
 68a:	24 30       	cpi	r18, 0x04	; 4
 68c:	31 05       	cpc	r19, r1
 68e:	80 f4       	brcc	.+32     	; 0x6b0 <malloc+0xa0>
 690:	8a 81       	ldd	r24, Y+2	; 0x02
 692:	9b 81       	ldd	r25, Y+3	; 0x03
 694:	61 15       	cp	r22, r1
 696:	71 05       	cpc	r23, r1
 698:	21 f0       	breq	.+8      	; 0x6a2 <malloc+0x92>
 69a:	fb 01       	movw	r30, r22
 69c:	93 83       	std	Z+3, r25	; 0x03
 69e:	82 83       	std	Z+2, r24	; 0x02
 6a0:	04 c0       	rjmp	.+8      	; 0x6aa <malloc+0x9a>
 6a2:	90 93 d0 01 	sts	0x01D0, r25
 6a6:	80 93 cf 01 	sts	0x01CF, r24
 6aa:	fe 01       	movw	r30, r28
 6ac:	32 96       	adiw	r30, 0x02	; 2
 6ae:	44 c0       	rjmp	.+136    	; 0x738 <malloc+0x128>
 6b0:	fe 01       	movw	r30, r28
 6b2:	e2 0f       	add	r30, r18
 6b4:	f3 1f       	adc	r31, r19
 6b6:	81 93       	st	Z+, r24
 6b8:	91 93       	st	Z+, r25
 6ba:	22 50       	subi	r18, 0x02	; 2
 6bc:	31 09       	sbc	r19, r1
 6be:	39 83       	std	Y+1, r19	; 0x01
 6c0:	28 83       	st	Y, r18
 6c2:	3a c0       	rjmp	.+116    	; 0x738 <malloc+0x128>
 6c4:	20 91 cd 01 	lds	r18, 0x01CD
 6c8:	30 91 ce 01 	lds	r19, 0x01CE
 6cc:	23 2b       	or	r18, r19
 6ce:	41 f4       	brne	.+16     	; 0x6e0 <malloc+0xd0>
 6d0:	20 91 62 00 	lds	r18, 0x0062
 6d4:	30 91 63 00 	lds	r19, 0x0063
 6d8:	30 93 ce 01 	sts	0x01CE, r19
 6dc:	20 93 cd 01 	sts	0x01CD, r18
 6e0:	20 91 60 00 	lds	r18, 0x0060
 6e4:	30 91 61 00 	lds	r19, 0x0061
 6e8:	21 15       	cp	r18, r1
 6ea:	31 05       	cpc	r19, r1
 6ec:	41 f4       	brne	.+16     	; 0x6fe <malloc+0xee>
 6ee:	2d b7       	in	r18, 0x3d	; 61
 6f0:	3e b7       	in	r19, 0x3e	; 62
 6f2:	40 91 64 00 	lds	r20, 0x0064
 6f6:	50 91 65 00 	lds	r21, 0x0065
 6fa:	24 1b       	sub	r18, r20
 6fc:	35 0b       	sbc	r19, r21
 6fe:	e0 91 cd 01 	lds	r30, 0x01CD
 702:	f0 91 ce 01 	lds	r31, 0x01CE
 706:	e2 17       	cp	r30, r18
 708:	f3 07       	cpc	r31, r19
 70a:	a0 f4       	brcc	.+40     	; 0x734 <malloc+0x124>
 70c:	2e 1b       	sub	r18, r30
 70e:	3f 0b       	sbc	r19, r31
 710:	28 17       	cp	r18, r24
 712:	39 07       	cpc	r19, r25
 714:	78 f0       	brcs	.+30     	; 0x734 <malloc+0x124>
 716:	ac 01       	movw	r20, r24
 718:	4e 5f       	subi	r20, 0xFE	; 254
 71a:	5f 4f       	sbci	r21, 0xFF	; 255
 71c:	24 17       	cp	r18, r20
 71e:	35 07       	cpc	r19, r21
 720:	48 f0       	brcs	.+18     	; 0x734 <malloc+0x124>
 722:	4e 0f       	add	r20, r30
 724:	5f 1f       	adc	r21, r31
 726:	50 93 ce 01 	sts	0x01CE, r21
 72a:	40 93 cd 01 	sts	0x01CD, r20
 72e:	81 93       	st	Z+, r24
 730:	91 93       	st	Z+, r25
 732:	02 c0       	rjmp	.+4      	; 0x738 <malloc+0x128>
 734:	e0 e0       	ldi	r30, 0x00	; 0
 736:	f0 e0       	ldi	r31, 0x00	; 0
 738:	cf 01       	movw	r24, r30
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	08 95       	ret

00000740 <free>:
 740:	cf 93       	push	r28
 742:	df 93       	push	r29
 744:	00 97       	sbiw	r24, 0x00	; 0
 746:	09 f4       	brne	.+2      	; 0x74a <free+0xa>
 748:	87 c0       	rjmp	.+270    	; 0x858 <free+0x118>
 74a:	fc 01       	movw	r30, r24
 74c:	32 97       	sbiw	r30, 0x02	; 2
 74e:	13 82       	std	Z+3, r1	; 0x03
 750:	12 82       	std	Z+2, r1	; 0x02
 752:	c0 91 cf 01 	lds	r28, 0x01CF
 756:	d0 91 d0 01 	lds	r29, 0x01D0
 75a:	20 97       	sbiw	r28, 0x00	; 0
 75c:	81 f4       	brne	.+32     	; 0x77e <free+0x3e>
 75e:	20 81       	ld	r18, Z
 760:	31 81       	ldd	r19, Z+1	; 0x01
 762:	28 0f       	add	r18, r24
 764:	39 1f       	adc	r19, r25
 766:	80 91 cd 01 	lds	r24, 0x01CD
 76a:	90 91 ce 01 	lds	r25, 0x01CE
 76e:	82 17       	cp	r24, r18
 770:	93 07       	cpc	r25, r19
 772:	79 f5       	brne	.+94     	; 0x7d2 <free+0x92>
 774:	f0 93 ce 01 	sts	0x01CE, r31
 778:	e0 93 cd 01 	sts	0x01CD, r30
 77c:	6d c0       	rjmp	.+218    	; 0x858 <free+0x118>
 77e:	de 01       	movw	r26, r28
 780:	20 e0       	ldi	r18, 0x00	; 0
 782:	30 e0       	ldi	r19, 0x00	; 0
 784:	ae 17       	cp	r26, r30
 786:	bf 07       	cpc	r27, r31
 788:	50 f4       	brcc	.+20     	; 0x79e <free+0x5e>
 78a:	12 96       	adiw	r26, 0x02	; 2
 78c:	4d 91       	ld	r20, X+
 78e:	5c 91       	ld	r21, X
 790:	13 97       	sbiw	r26, 0x03	; 3
 792:	9d 01       	movw	r18, r26
 794:	41 15       	cp	r20, r1
 796:	51 05       	cpc	r21, r1
 798:	09 f1       	breq	.+66     	; 0x7dc <free+0x9c>
 79a:	da 01       	movw	r26, r20
 79c:	f3 cf       	rjmp	.-26     	; 0x784 <free+0x44>
 79e:	b3 83       	std	Z+3, r27	; 0x03
 7a0:	a2 83       	std	Z+2, r26	; 0x02
 7a2:	40 81       	ld	r20, Z
 7a4:	51 81       	ldd	r21, Z+1	; 0x01
 7a6:	84 0f       	add	r24, r20
 7a8:	95 1f       	adc	r25, r21
 7aa:	8a 17       	cp	r24, r26
 7ac:	9b 07       	cpc	r25, r27
 7ae:	71 f4       	brne	.+28     	; 0x7cc <free+0x8c>
 7b0:	8d 91       	ld	r24, X+
 7b2:	9c 91       	ld	r25, X
 7b4:	11 97       	sbiw	r26, 0x01	; 1
 7b6:	84 0f       	add	r24, r20
 7b8:	95 1f       	adc	r25, r21
 7ba:	02 96       	adiw	r24, 0x02	; 2
 7bc:	91 83       	std	Z+1, r25	; 0x01
 7be:	80 83       	st	Z, r24
 7c0:	12 96       	adiw	r26, 0x02	; 2
 7c2:	8d 91       	ld	r24, X+
 7c4:	9c 91       	ld	r25, X
 7c6:	13 97       	sbiw	r26, 0x03	; 3
 7c8:	93 83       	std	Z+3, r25	; 0x03
 7ca:	82 83       	std	Z+2, r24	; 0x02
 7cc:	21 15       	cp	r18, r1
 7ce:	31 05       	cpc	r19, r1
 7d0:	29 f4       	brne	.+10     	; 0x7dc <free+0x9c>
 7d2:	f0 93 d0 01 	sts	0x01D0, r31
 7d6:	e0 93 cf 01 	sts	0x01CF, r30
 7da:	3e c0       	rjmp	.+124    	; 0x858 <free+0x118>
 7dc:	d9 01       	movw	r26, r18
 7de:	13 96       	adiw	r26, 0x03	; 3
 7e0:	fc 93       	st	X, r31
 7e2:	ee 93       	st	-X, r30
 7e4:	12 97       	sbiw	r26, 0x02	; 2
 7e6:	4d 91       	ld	r20, X+
 7e8:	5d 91       	ld	r21, X+
 7ea:	a4 0f       	add	r26, r20
 7ec:	b5 1f       	adc	r27, r21
 7ee:	ea 17       	cp	r30, r26
 7f0:	fb 07       	cpc	r31, r27
 7f2:	79 f4       	brne	.+30     	; 0x812 <free+0xd2>
 7f4:	80 81       	ld	r24, Z
 7f6:	91 81       	ldd	r25, Z+1	; 0x01
 7f8:	84 0f       	add	r24, r20
 7fa:	95 1f       	adc	r25, r21
 7fc:	02 96       	adiw	r24, 0x02	; 2
 7fe:	d9 01       	movw	r26, r18
 800:	11 96       	adiw	r26, 0x01	; 1
 802:	9c 93       	st	X, r25
 804:	8e 93       	st	-X, r24
 806:	82 81       	ldd	r24, Z+2	; 0x02
 808:	93 81       	ldd	r25, Z+3	; 0x03
 80a:	13 96       	adiw	r26, 0x03	; 3
 80c:	9c 93       	st	X, r25
 80e:	8e 93       	st	-X, r24
 810:	12 97       	sbiw	r26, 0x02	; 2
 812:	e0 e0       	ldi	r30, 0x00	; 0
 814:	f0 e0       	ldi	r31, 0x00	; 0
 816:	8a 81       	ldd	r24, Y+2	; 0x02
 818:	9b 81       	ldd	r25, Y+3	; 0x03
 81a:	00 97       	sbiw	r24, 0x00	; 0
 81c:	19 f0       	breq	.+6      	; 0x824 <free+0xe4>
 81e:	fe 01       	movw	r30, r28
 820:	ec 01       	movw	r28, r24
 822:	f9 cf       	rjmp	.-14     	; 0x816 <free+0xd6>
 824:	ce 01       	movw	r24, r28
 826:	02 96       	adiw	r24, 0x02	; 2
 828:	28 81       	ld	r18, Y
 82a:	39 81       	ldd	r19, Y+1	; 0x01
 82c:	82 0f       	add	r24, r18
 82e:	93 1f       	adc	r25, r19
 830:	20 91 cd 01 	lds	r18, 0x01CD
 834:	30 91 ce 01 	lds	r19, 0x01CE
 838:	28 17       	cp	r18, r24
 83a:	39 07       	cpc	r19, r25
 83c:	69 f4       	brne	.+26     	; 0x858 <free+0x118>
 83e:	30 97       	sbiw	r30, 0x00	; 0
 840:	29 f4       	brne	.+10     	; 0x84c <free+0x10c>
 842:	10 92 d0 01 	sts	0x01D0, r1
 846:	10 92 cf 01 	sts	0x01CF, r1
 84a:	02 c0       	rjmp	.+4      	; 0x850 <free+0x110>
 84c:	13 82       	std	Z+3, r1	; 0x03
 84e:	12 82       	std	Z+2, r1	; 0x02
 850:	d0 93 ce 01 	sts	0x01CE, r29
 854:	c0 93 cd 01 	sts	0x01CD, r28
 858:	df 91       	pop	r29
 85a:	cf 91       	pop	r28
 85c:	08 95       	ret

0000085e <_exit>:
 85e:	f8 94       	cli

00000860 <__stop_program>:
 860:	ff cf       	rjmp	.-2      	; 0x860 <__stop_program>
