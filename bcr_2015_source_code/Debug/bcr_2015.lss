
bcr_2015.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000618  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  00000618  000006ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000015f  00800078  00800078  000006c4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000006c4  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000001a8  00000000  00000000  000006f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000010f0  00000000  00000000  0000089c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000008c6  00000000  00000000  0000198c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a53  00000000  00000000  00002252  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000330  00000000  00000000  00002ca8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005df  00000000  00000000  00002fd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006e0  00000000  00000000  000035b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000140  00000000  00000000  00003c97  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *  Author: Vo Huu Tai
 */ 
#include "../inc/hardware_feature.h"

bool bKeyIsPress(uint8_t ucKeyID){
	uint8_t mask = (1<<ucKeyID);
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	//key is pressed when pin = 0;
	if((PIN_KEY & mask) != mask){
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 aa 01 	jmp	0x354	; 0x354 <__vector_9>
		_delay_ms(10);
		if((PIN_KEY & mask) != mask){
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 2a 01 	jmp	0x254	; 0x254 <__vector_11>
			LED_BUG_ON;
  30:	0c 94 56 01 	jmp	0x2ac	; 0x2ac <__vector_12>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
			_delay_ms(10);
			while((PIN_KEY&mask)!=mask);//waiting for key is released
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
			LED_BUG_OFF;
			return true;
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		}
	}
	return false;
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
	}	
	vLedCtrl(LED_FAST_BLINK);
	_delay_ms(10000);
	vLedCtrl(LED_SLOW_BLINK);
	_delay_ms(10000);
	vLedCtrl(LED_STARTUP_COMPELETE);
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 e1       	ldi	r30, 0x18	; 24
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a8 37       	cpi	r26, 0x78	; 120
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	21 e0       	ldi	r18, 0x01	; 1
  78:	a8 e7       	ldi	r26, 0x78	; 120
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a7 3d       	cpi	r26, 0xD7	; 215
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 9e 01 	call	0x33c	; 0x33c <main>
  8a:	0c 94 0a 03 	jmp	0x614	; 0x614 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <v_init_debug_via_uart>:
			sUartPacket.length = ptr_rx_buff[1];
			for(uint8_t i = 0; i < sUartPacket.length; i++){
				ptr_command_data[i] = ptr_rx_buff[i+2];
			}
			sUartPacket.data = ptr_command_data;
			sUartPacket.checksum = ptr_rx_buff[sUartPacket.length + 2];
  92:	86 e2       	ldi	r24, 0x26	; 38
  94:	90 e0       	ldi	r25, 0x00	; 0
  96:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uart_init>
  9a:	86 e6       	ldi	r24, 0x66	; 102
  9c:	90 e0       	ldi	r25, 0x00	; 0
				printf(" %d",sUartPacket.data[i]);
			}
			printf("\nCheck sum: %d",sUartPacket.checksum);
			#endif
		   
			bIsDubugCommandCompelete = true;
  9e:	90 93 d4 01 	sts	0x01D4, r25
  a2:	80 93 d3 01 	sts	0x01D3, r24
		}
		else { //get data
			bIsDubugCommandCompelete = false;
  a6:	82 e0       	ldi	r24, 0x02	; 2
  a8:	90 e0       	ldi	r25, 0x00	; 0
			ptr_rx_buff[index_rx_buf++] = c;			
  aa:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <malloc>
  ae:	90 93 c8 01 	sts	0x01C8, r25
  b2:	80 93 c7 01 	sts	0x01C7, r24
  b6:	81 e0       	ldi	r24, 0x01	; 1
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <malloc>
  be:	90 93 cc 01 	sts	0x01CC, r25
  c2:	80 93 cb 01 	sts	0x01CB, r24
  c6:	10 92 ca 01 	sts	0x01CA, r1
  ca:	10 92 c9 01 	sts	0x01C9, r1
  ce:	08 95       	ret

000000d0 <vInitTimer0>:
				Normal mode.
				F = 12Mhz
				T = 5.33333us
				=> prescaler = 64
	*/
	TCCR0 = (1 << CS01) | (1<<CS00);
  d0:	83 e0       	ldi	r24, 0x03	; 3
  d2:	83 bf       	out	0x33, r24	; 51
	TIMSK |= (1 << TOIE0);
  d4:	89 b7       	in	r24, 0x39	; 57
  d6:	81 60       	ori	r24, 0x01	; 1
  d8:	89 bf       	out	0x39, r24	; 57
  da:	08 95       	ret

000000dc <vInitTimer1>:
				F = 12Mhz
				T = 15ms
				=> prescaler = 8.
				ICR1 = 15ms / ((1/12Mhz)*8) = 22500	
	*/
	TCCR1A = (1 << WGM11) | (1 << COM1A1) | (1 << COM1B1);
  dc:	82 ea       	ldi	r24, 0xA2	; 162
  de:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
  e0:	8a e1       	ldi	r24, 0x1A	; 26
  e2:	8e bd       	out	0x2e, r24	; 46
	ICR1 = 22500;
  e4:	84 ee       	ldi	r24, 0xE4	; 228
  e6:	97 e5       	ldi	r25, 0x57	; 87
  e8:	97 bd       	out	0x27, r25	; 39
  ea:	86 bd       	out	0x26, r24	; 38
	OCR1B = 2000;
  ec:	80 ed       	ldi	r24, 0xD0	; 208
  ee:	97 e0       	ldi	r25, 0x07	; 7
  f0:	99 bd       	out	0x29, r25	; 41
  f2:	88 bd       	out	0x28, r24	; 40
  f4:	08 95       	ret

000000f6 <vInitTimer2>:
				Non-inverting: COM2[1:0] = 10
				F = 12Mhz
				T = 5.5ms
				=> prescaler = 256.
	*/
	TCCR2 = (1 << WGM21) | (1 << WGM20) | (1 << COM21) | (1 << CS22) | (1 << CS21);
  f6:	8e e6       	ldi	r24, 0x6E	; 110
  f8:	85 bd       	out	0x25, r24	; 37
	OCR2 = 100;
  fa:	84 e6       	ldi	r24, 0x64	; 100
  fc:	83 bd       	out	0x23, r24	; 35
  fe:	08 95       	ret

00000100 <vInitProgram>:
#include "../inc/hardware_config.h"
#include "../inc/debug.h"

void vInitProgram(){
	//disable local interrupt
	cli();
 100:	f8 94       	cli
	
	//IO initialize
	LED_BUB_INIT;		//Led debug is output
 102:	bf 9a       	sbi	0x17, 7	; 23
 104:	c7 9a       	sbi	0x18, 7	; 24
	KEY_INIT;			//Key is input
 106:	b8 98       	cbi	0x17, 0	; 23
 108:	c0 9a       	sbi	0x18, 0	; 24
 10a:	b9 98       	cbi	0x17, 1	; 23
 10c:	c1 9a       	sbi	0x18, 1	; 24
 10e:	ba 98       	cbi	0x17, 2	; 23
 110:	c2 9a       	sbi	0x18, 2	; 24
	SWITCH_INIT;		//Switch is input
 112:	a3 98       	cbi	0x14, 3	; 20
 114:	ab 9a       	sbi	0x15, 3	; 21
 116:	a2 98       	cbi	0x14, 2	; 20
 118:	aa 9a       	sbi	0x15, 2	; 21
 11a:	a1 98       	cbi	0x14, 1	; 20
 11c:	a9 9a       	sbi	0x15, 1	; 21
 11e:	a0 98       	cbi	0x14, 0	; 20
 120:	a8 9a       	sbi	0x15, 0	; 21
	MOTOR_LEFT_INIT;
 122:	bc 9a       	sbi	0x17, 4	; 23
 124:	be 9a       	sbi	0x17, 6	; 23
 126:	c6 9a       	sbi	0x18, 6	; 24
 128:	8c 9a       	sbi	0x11, 4	; 17
	MOTOR_RIGHT_INIT;
 12a:	bb 9a       	sbi	0x17, 3	; 23
 12c:	bd 9a       	sbi	0x17, 5	; 23
 12e:	c5 9a       	sbi	0x18, 5	; 24
 130:	8f 9a       	sbi	0x11, 7	; 17
	SLAVE_ENABLE_INIT;
 132:	a4 9a       	sbi	0x14, 4	; 20
	SLAVE_ON;
 134:	ac 9a       	sbi	0x15, 4	; 21
	
	//Timer and PWM
	vInitTimer0();
 136:	0e 94 68 00 	call	0xd0	; 0xd0 <vInitTimer0>
	vInitTimer1();
 13a:	0e 94 6e 00 	call	0xdc	; 0xdc <vInitTimer1>
	vInitTimer2();	
 13e:	0e 94 7b 00 	call	0xf6	; 0xf6 <vInitTimer2>
	
	//SERIAL
	v_init_debug_via_uart();
 142:	0e 94 49 00 	call	0x92	; 0x92 <v_init_debug_via_uart>
	//enable local interrupt
	sei();
 146:	78 94       	sei
 148:	08 95       	ret

0000014a <vPeriodicDec>:
	@param:		none
	@return:	none 
*/

void vPeriodicDec(){	
	if(uigLedPeriodic == 0 ){
 14a:	80 91 76 00 	lds	r24, 0x0076
 14e:	90 91 77 00 	lds	r25, 0x0077
 152:	89 2b       	or	r24, r25
 154:	39 f4       	brne	.+14     	; 0x164 <vPeriodicDec+0x1a>
		uigLedPeriodic = NO_LIMIT;
 156:	8f ef       	ldi	r24, 0xFF	; 255
 158:	9f ef       	ldi	r25, 0xFF	; 255
 15a:	90 93 77 00 	sts	0x0077, r25
 15e:	80 93 76 00 	sts	0x0076, r24
 162:	08 95       	ret
	}else
	uigLedPeriodic--;	
 164:	80 91 76 00 	lds	r24, 0x0076
 168:	90 91 77 00 	lds	r25, 0x0077
 16c:	01 97       	sbiw	r24, 0x01	; 1
 16e:	90 93 77 00 	sts	0x0077, r25
 172:	80 93 76 00 	sts	0x0076, r24
 176:	08 95       	ret

00000178 <vIntervalDec>:
	@param:		none
	@return:	none 
*/
void vIntervalDec(){
	
	if(uigLedInterval == 0){
 178:	80 91 74 00 	lds	r24, 0x0074
 17c:	90 91 75 00 	lds	r25, 0x0075
 180:	89 2b       	or	r24, r25
 182:	39 f4       	brne	.+14     	; 0x192 <vIntervalDec+0x1a>
		uigLedInterval = NO_LIMIT;
 184:	8f ef       	ldi	r24, 0xFF	; 255
 186:	9f ef       	ldi	r25, 0xFF	; 255
 188:	90 93 75 00 	sts	0x0075, r25
 18c:	80 93 74 00 	sts	0x0074, r24
 190:	08 95       	ret
	}
	else
	uigLedInterval--;	
 192:	80 91 74 00 	lds	r24, 0x0074
 196:	90 91 75 00 	lds	r25, 0x0075
 19a:	01 97       	sbiw	r24, 0x01	; 1
 19c:	90 93 75 00 	sts	0x0075, r25
 1a0:	80 93 74 00 	sts	0x0074, r24
 1a4:	08 95       	ret

000001a6 <ucPareLedEvent>:
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
	switch(led_event){
 1a6:	82 30       	cpi	r24, 0x02	; 2
 1a8:	69 f0       	breq	.+26     	; 0x1c4 <ucPareLedEvent+0x1e>
 1aa:	83 30       	cpi	r24, 0x03	; 3
 1ac:	a1 f0       	breq	.+40     	; 0x1d6 <ucPareLedEvent+0x30>
 1ae:	81 30       	cpi	r24, 0x01	; 1
 1b0:	d9 f4       	brne	.+54     	; 0x1e8 <ucPareLedEvent+0x42>
		case LED_FAST_BLINK:			
			uigLedInterval = LED_50_MS;			
 1b2:	85 e0       	ldi	r24, 0x05	; 5
 1b4:	90 e0       	ldi	r25, 0x00	; 0
 1b6:	90 93 75 00 	sts	0x0075, r25
 1ba:	80 93 74 00 	sts	0x0074, r24
	@brief:		parse control for led
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
 1be:	8f ef       	ldi	r24, 0xFF	; 255
 1c0:	9f ef       	ldi	r25, 0xFF	; 255
	switch(led_event){
		case LED_FAST_BLINK:			
			uigLedInterval = LED_50_MS;			
			break;
 1c2:	08 95       	ret
		case LED_SLOW_BLINK:			
			uigLedInterval = LED_100_MS;			
 1c4:	8a e0       	ldi	r24, 0x0A	; 10
 1c6:	90 e0       	ldi	r25, 0x00	; 0
 1c8:	90 93 75 00 	sts	0x0075, r25
 1cc:	80 93 74 00 	sts	0x0074, r24
	@brief:		parse control for led
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
 1d0:	8f ef       	ldi	r24, 0xFF	; 255
 1d2:	9f ef       	ldi	r25, 0xFF	; 255
		case LED_FAST_BLINK:			
			uigLedInterval = LED_50_MS;			
			break;
		case LED_SLOW_BLINK:			
			uigLedInterval = LED_100_MS;			
			break;
 1d4:	08 95       	ret
		case LED_STARTUP_COMPELETE:			
			uigLedInterval = LED_50_MS;	
 1d6:	85 e0       	ldi	r24, 0x05	; 5
 1d8:	90 e0       	ldi	r25, 0x00	; 0
 1da:	90 93 75 00 	sts	0x0075, r25
 1de:	80 93 74 00 	sts	0x0074, r24
			uiRet = LED_10_S;	
 1e2:	88 ee       	ldi	r24, 0xE8	; 232
 1e4:	93 e0       	ldi	r25, 0x03	; 3
			break;		
 1e6:	08 95       	ret
	@brief:		parse control for led
	@param:		led event
	@return:	Led Periodic counter
*/
uint16_t ucPareLedEvent(uint8_t led_event){
	uint16_t uiRet = NO_LIMIT;
 1e8:	8f ef       	ldi	r24, 0xFF	; 255
 1ea:	9f ef       	ldi	r25, 0xFF	; 255
			break;		
		default:			
			break;
	}
	return uiRet;
}
 1ec:	08 95       	ret

000001ee <vLedFlash>:
//
void vLedFlash(){
 1ee:	cf 93       	push	r28
	uint8_t ucStateTemp = ucgLedState;	
 1f0:	c0 91 7a 00 	lds	r28, 0x007A
	
	switch(ucStateTemp){
 1f4:	cc 23       	and	r28, r28
 1f6:	61 f1       	breq	.+88     	; 0x250 <vLedFlash+0x62>
 1f8:	c1 30       	cpi	r28, 0x01	; 1
 1fa:	41 f5       	brne	.+80     	; 0x24c <vLedFlash+0x5e>
		case LED_STATE_NONE:	//State NONE do nothing.
			return;
		case LED_STATE_BLINK:		
			vPeriodicDec();
 1fc:	0e 94 a5 00 	call	0x14a	; 0x14a <vPeriodicDec>
			if(uigLedPeriodic == 0){
 200:	80 91 76 00 	lds	r24, 0x0076
 204:	90 91 77 00 	lds	r25, 0x0077
 208:	89 2b       	or	r24, r25
 20a:	29 f4       	brne	.+10     	; 0x216 <vLedFlash+0x28>
				LED_BUG_OFF; //turn off led
 20c:	c7 9a       	sbi	0x18, 7	; 24
				bgLedFlag = LED_FLAG_OFF;//set flag is off
 20e:	10 92 79 00 	sts	0x0079, r1
				ucStateTemp = LED_STATE_NONE;
 212:	c0 e0       	ldi	r28, 0x00	; 0
 214:	1b c0       	rjmp	.+54     	; 0x24c <vLedFlash+0x5e>
			}
			else{
				vIntervalDec();
 216:	0e 94 bc 00 	call	0x178	; 0x178 <vIntervalDec>
				if(uigLedInterval == 0){
 21a:	80 91 74 00 	lds	r24, 0x0074
 21e:	90 91 75 00 	lds	r25, 0x0075
 222:	89 2b       	or	r24, r25
 224:	99 f4       	brne	.+38     	; 0x24c <vLedFlash+0x5e>
					switch (bgLedFlag)
 226:	80 91 79 00 	lds	r24, 0x0079
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	00 97       	sbiw	r24, 0x00	; 0
 22e:	31 f0       	breq	.+12     	; 0x23c <vLedFlash+0x4e>
 230:	01 97       	sbiw	r24, 0x01	; 1
 232:	41 f4       	brne	.+16     	; 0x244 <vLedFlash+0x56>
					{
						case LED_FLAG_ON:
							bgLedFlag = LED_FLAG_OFF;
 234:	10 92 79 00 	sts	0x0079, r1
							LED_BUG_OFF;
 238:	c7 9a       	sbi	0x18, 7	; 24
							break;
 23a:	04 c0       	rjmp	.+8      	; 0x244 <vLedFlash+0x56>
						case LED_FLAG_OFF:
							bgLedFlag = LED_FLAG_ON;
 23c:	81 e0       	ldi	r24, 0x01	; 1
 23e:	80 93 79 00 	sts	0x0079, r24
							LED_BUG_ON;
 242:	c7 98       	cbi	0x18, 7	; 24
							break;
						default:							
							break;
					}					
					ucPareLedEvent(ucLedEvent);					
 244:	80 91 78 00 	lds	r24, 0x0078
 248:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <ucPareLedEvent>
			}
			break;
		default:			
			break;		
	}		
	ucgLedState = ucStateTemp;		
 24c:	c0 93 7a 00 	sts	0x007A, r28
}
 250:	cf 91       	pop	r28
 252:	08 95       	ret

00000254 <__vector_11>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
 254:	1f 92       	push	r1
 256:	0f 92       	push	r0
 258:	0f b6       	in	r0, 0x3f	; 63
 25a:	0f 92       	push	r0
 25c:	11 24       	eor	r1, r1
 25e:	2f 93       	push	r18
 260:	8f 93       	push	r24
 262:	9f 93       	push	r25
 264:	ef 93       	push	r30
 266:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
 268:	8b b1       	in	r24, 0x0b	; 11
    data = UART0_DATA;
 26a:	2c b1       	in	r18, 0x0c	; 12
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 26c:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 26e:	e0 91 7d 00 	lds	r30, 0x007D
 272:	ef 5f       	subi	r30, 0xFF	; 255
 274:	ef 73       	andi	r30, 0x3F	; 63
    
    if ( tmphead == UART_RxTail ) {
 276:	90 91 7c 00 	lds	r25, 0x007C
 27a:	e9 17       	cp	r30, r25
 27c:	39 f0       	breq	.+14     	; 0x28c <__vector_11+0x38>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
 27e:	e0 93 7d 00 	sts	0x007D, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
 282:	f0 e0       	ldi	r31, 0x00	; 0
 284:	e0 58       	subi	r30, 0x80	; 128
 286:	ff 4f       	sbci	r31, 0xFF	; 255
 288:	20 83       	st	Z, r18
 28a:	01 c0       	rjmp	.+2      	; 0x28e <__vector_11+0x3a>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
 28c:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
 28e:	90 91 7b 00 	lds	r25, 0x007B
 292:	89 2b       	or	r24, r25
 294:	80 93 7b 00 	sts	0x007B, r24
}
 298:	ff 91       	pop	r31
 29a:	ef 91       	pop	r30
 29c:	9f 91       	pop	r25
 29e:	8f 91       	pop	r24
 2a0:	2f 91       	pop	r18
 2a2:	0f 90       	pop	r0
 2a4:	0f be       	out	0x3f, r0	; 63
 2a6:	0f 90       	pop	r0
 2a8:	1f 90       	pop	r1
 2aa:	18 95       	reti

000002ac <__vector_12>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
 2ac:	1f 92       	push	r1
 2ae:	0f 92       	push	r0
 2b0:	0f b6       	in	r0, 0x3f	; 63
 2b2:	0f 92       	push	r0
 2b4:	11 24       	eor	r1, r1
 2b6:	8f 93       	push	r24
 2b8:	9f 93       	push	r25
 2ba:	ef 93       	push	r30
 2bc:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
 2be:	90 91 7f 00 	lds	r25, 0x007F
 2c2:	80 91 7e 00 	lds	r24, 0x007E
 2c6:	98 17       	cp	r25, r24
 2c8:	59 f0       	breq	.+22     	; 0x2e0 <__vector_12+0x34>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 2ca:	e0 91 7e 00 	lds	r30, 0x007E
 2ce:	ef 5f       	subi	r30, 0xFF	; 255
        UART_TxTail = tmptail;
 2d0:	e0 93 7e 00 	sts	0x007E, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 2d4:	f0 e0       	ldi	r31, 0x00	; 0
 2d6:	e0 54       	subi	r30, 0x40	; 64
 2d8:	ff 4f       	sbci	r31, 0xFF	; 255
 2da:	80 81       	ld	r24, Z
 2dc:	8c b9       	out	0x0c, r24	; 12
 2de:	01 c0       	rjmp	.+2      	; 0x2e2 <__vector_12+0x36>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
 2e0:	55 98       	cbi	0x0a, 5	; 10
    }
}
 2e2:	ff 91       	pop	r31
 2e4:	ef 91       	pop	r30
 2e6:	9f 91       	pop	r25
 2e8:	8f 91       	pop	r24
 2ea:	0f 90       	pop	r0
 2ec:	0f be       	out	0x3f, r0	; 63
 2ee:	0f 90       	pop	r0
 2f0:	1f 90       	pop	r1
 2f2:	18 95       	reti

000002f4 <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
 2f4:	10 92 7f 00 	sts	0x007F, r1
    UART_TxTail = 0;
 2f8:	10 92 7e 00 	sts	0x007E, r1
    UART_RxHead = 0;
 2fc:	10 92 7d 00 	sts	0x007D, r1
    UART_RxTail = 0;
 300:	10 92 7c 00 	sts	0x007C, r1
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
 304:	99 23       	and	r25, r25
 306:	1c f4       	brge	.+6      	; 0x30e <uart_init+0x1a>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 308:	22 e0       	ldi	r18, 0x02	; 2
 30a:	2b b9       	out	0x0b, r18	; 11
    	 baudrate &= ~0x8000;
 30c:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
 30e:	90 bd       	out	0x20, r25	; 32
    UBRRL = (unsigned char) baudrate;
 310:	89 b9       	out	0x09, r24	; 9
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 312:	88 e9       	ldi	r24, 0x98	; 152
 314:	8a b9       	out	0x0a, r24	; 10
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
 316:	86 e8       	ldi	r24, 0x86	; 134
 318:	80 bd       	out	0x20, r24	; 32
 31a:	08 95       	ret

0000031c <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 31c:	20 91 7f 00 	lds	r18, 0x007F
 320:	2f 5f       	subi	r18, 0xFF	; 255
    
    while ( tmphead == UART_TxTail ){
 322:	90 91 7e 00 	lds	r25, 0x007E
 326:	29 17       	cp	r18, r25
 328:	e1 f3       	breq	.-8      	; 0x322 <uart_putc+0x6>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
 32a:	e2 2f       	mov	r30, r18
 32c:	f0 e0       	ldi	r31, 0x00	; 0
 32e:	e0 54       	subi	r30, 0x40	; 64
 330:	ff 4f       	sbci	r31, 0xFF	; 255
 332:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
 334:	20 93 7f 00 	sts	0x007F, r18

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
 338:	55 9a       	sbi	0x0a, 5	; 10
 33a:	08 95       	ret

0000033c <main>:
#include "../lib/inc/debug.h"
//#define UNIT_TEST

int main(void)
{
	vInitProgram();	
 33c:	0e 94 80 00 	call	0x100	; 0x100 <vInitProgram>
 340:	2f ef       	ldi	r18, 0xFF	; 255
 342:	83 ed       	ldi	r24, 0xD3	; 211
 344:	90 e3       	ldi	r25, 0x30	; 48
 346:	21 50       	subi	r18, 0x01	; 1
 348:	80 40       	sbci	r24, 0x00	; 0
 34a:	90 40       	sbci	r25, 0x00	; 0
 34c:	e1 f7       	brne	.-8      	; 0x346 <main+0xa>
 34e:	00 c0       	rjmp	.+0      	; 0x350 <main+0x14>
 350:	00 00       	nop
 352:	f6 cf       	rjmp	.-20     	; 0x340 <main+0x4>

00000354 <__vector_9>:
		
    }
}
volatile uint16_t uiTimer0Cnt = 0;
ISR(TIMER0_OVF_vect)
{
 354:	1f 92       	push	r1
 356:	0f 92       	push	r0
 358:	0f b6       	in	r0, 0x3f	; 63
 35a:	0f 92       	push	r0
 35c:	11 24       	eor	r1, r1
 35e:	2f 93       	push	r18
 360:	3f 93       	push	r19
 362:	4f 93       	push	r20
 364:	5f 93       	push	r21
 366:	6f 93       	push	r22
 368:	7f 93       	push	r23
 36a:	8f 93       	push	r24
 36c:	9f 93       	push	r25
 36e:	af 93       	push	r26
 370:	bf 93       	push	r27
 372:	ef 93       	push	r30
 374:	ff 93       	push	r31
	TCNT0 = 68;	//~1ms
 376:	84 e4       	ldi	r24, 0x44	; 68
 378:	82 bf       	out	0x32, r24	; 50
	uiTimer0Cnt++;
 37a:	80 91 c0 01 	lds	r24, 0x01C0
 37e:	90 91 c1 01 	lds	r25, 0x01C1
 382:	01 96       	adiw	r24, 0x01	; 1
 384:	90 93 c1 01 	sts	0x01C1, r25
 388:	80 93 c0 01 	sts	0x01C0, r24
	if(uiTimer0Cnt == 10){//10ms
 38c:	80 91 c0 01 	lds	r24, 0x01C0
 390:	90 91 c1 01 	lds	r25, 0x01C1
 394:	0a 97       	sbiw	r24, 0x0a	; 10
 396:	31 f4       	brne	.+12     	; 0x3a4 <__vector_9+0x50>
		uiTimer0Cnt = 0;
 398:	10 92 c1 01 	sts	0x01C1, r1
 39c:	10 92 c0 01 	sts	0x01C0, r1
		vLedFlash();
 3a0:	0e 94 f7 00 	call	0x1ee	; 0x1ee <vLedFlash>
	}
	
 3a4:	ff 91       	pop	r31
 3a6:	ef 91       	pop	r30
 3a8:	bf 91       	pop	r27
 3aa:	af 91       	pop	r26
 3ac:	9f 91       	pop	r25
 3ae:	8f 91       	pop	r24
 3b0:	7f 91       	pop	r23
 3b2:	6f 91       	pop	r22
 3b4:	5f 91       	pop	r21
 3b6:	4f 91       	pop	r20
 3b8:	3f 91       	pop	r19
 3ba:	2f 91       	pop	r18
 3bc:	0f 90       	pop	r0
 3be:	0f be       	out	0x3f, r0	; 63
 3c0:	0f 90       	pop	r0
 3c2:	1f 90       	pop	r1
 3c4:	18 95       	reti

000003c6 <malloc>:
 3c6:	cf 93       	push	r28
 3c8:	df 93       	push	r29
 3ca:	82 30       	cpi	r24, 0x02	; 2
 3cc:	91 05       	cpc	r25, r1
 3ce:	10 f4       	brcc	.+4      	; 0x3d4 <malloc+0xe>
 3d0:	82 e0       	ldi	r24, 0x02	; 2
 3d2:	90 e0       	ldi	r25, 0x00	; 0
 3d4:	e0 91 cf 01 	lds	r30, 0x01CF
 3d8:	f0 91 d0 01 	lds	r31, 0x01D0
 3dc:	20 e0       	ldi	r18, 0x00	; 0
 3de:	30 e0       	ldi	r19, 0x00	; 0
 3e0:	a0 e0       	ldi	r26, 0x00	; 0
 3e2:	b0 e0       	ldi	r27, 0x00	; 0
 3e4:	30 97       	sbiw	r30, 0x00	; 0
 3e6:	39 f1       	breq	.+78     	; 0x436 <malloc+0x70>
 3e8:	40 81       	ld	r20, Z
 3ea:	51 81       	ldd	r21, Z+1	; 0x01
 3ec:	48 17       	cp	r20, r24
 3ee:	59 07       	cpc	r21, r25
 3f0:	b8 f0       	brcs	.+46     	; 0x420 <malloc+0x5a>
 3f2:	48 17       	cp	r20, r24
 3f4:	59 07       	cpc	r21, r25
 3f6:	71 f4       	brne	.+28     	; 0x414 <malloc+0x4e>
 3f8:	82 81       	ldd	r24, Z+2	; 0x02
 3fa:	93 81       	ldd	r25, Z+3	; 0x03
 3fc:	10 97       	sbiw	r26, 0x00	; 0
 3fe:	29 f0       	breq	.+10     	; 0x40a <malloc+0x44>
 400:	13 96       	adiw	r26, 0x03	; 3
 402:	9c 93       	st	X, r25
 404:	8e 93       	st	-X, r24
 406:	12 97       	sbiw	r26, 0x02	; 2
 408:	2c c0       	rjmp	.+88     	; 0x462 <__stack+0x3>
 40a:	90 93 d0 01 	sts	0x01D0, r25
 40e:	80 93 cf 01 	sts	0x01CF, r24
 412:	27 c0       	rjmp	.+78     	; 0x462 <__stack+0x3>
 414:	21 15       	cp	r18, r1
 416:	31 05       	cpc	r19, r1
 418:	31 f0       	breq	.+12     	; 0x426 <malloc+0x60>
 41a:	42 17       	cp	r20, r18
 41c:	53 07       	cpc	r21, r19
 41e:	18 f0       	brcs	.+6      	; 0x426 <malloc+0x60>
 420:	a9 01       	movw	r20, r18
 422:	db 01       	movw	r26, r22
 424:	01 c0       	rjmp	.+2      	; 0x428 <malloc+0x62>
 426:	ef 01       	movw	r28, r30
 428:	9a 01       	movw	r18, r20
 42a:	bd 01       	movw	r22, r26
 42c:	df 01       	movw	r26, r30
 42e:	02 80       	ldd	r0, Z+2	; 0x02
 430:	f3 81       	ldd	r31, Z+3	; 0x03
 432:	e0 2d       	mov	r30, r0
 434:	d7 cf       	rjmp	.-82     	; 0x3e4 <malloc+0x1e>
 436:	21 15       	cp	r18, r1
 438:	31 05       	cpc	r19, r1
 43a:	f9 f0       	breq	.+62     	; 0x47a <__stack+0x1b>
 43c:	28 1b       	sub	r18, r24
 43e:	39 0b       	sbc	r19, r25
 440:	24 30       	cpi	r18, 0x04	; 4
 442:	31 05       	cpc	r19, r1
 444:	80 f4       	brcc	.+32     	; 0x466 <__stack+0x7>
 446:	8a 81       	ldd	r24, Y+2	; 0x02
 448:	9b 81       	ldd	r25, Y+3	; 0x03
 44a:	61 15       	cp	r22, r1
 44c:	71 05       	cpc	r23, r1
 44e:	21 f0       	breq	.+8      	; 0x458 <malloc+0x92>
 450:	fb 01       	movw	r30, r22
 452:	93 83       	std	Z+3, r25	; 0x03
 454:	82 83       	std	Z+2, r24	; 0x02
 456:	04 c0       	rjmp	.+8      	; 0x460 <__stack+0x1>
 458:	90 93 d0 01 	sts	0x01D0, r25
 45c:	80 93 cf 01 	sts	0x01CF, r24
 460:	fe 01       	movw	r30, r28
 462:	32 96       	adiw	r30, 0x02	; 2
 464:	44 c0       	rjmp	.+136    	; 0x4ee <__stack+0x8f>
 466:	fe 01       	movw	r30, r28
 468:	e2 0f       	add	r30, r18
 46a:	f3 1f       	adc	r31, r19
 46c:	81 93       	st	Z+, r24
 46e:	91 93       	st	Z+, r25
 470:	22 50       	subi	r18, 0x02	; 2
 472:	31 09       	sbc	r19, r1
 474:	39 83       	std	Y+1, r19	; 0x01
 476:	28 83       	st	Y, r18
 478:	3a c0       	rjmp	.+116    	; 0x4ee <__stack+0x8f>
 47a:	20 91 cd 01 	lds	r18, 0x01CD
 47e:	30 91 ce 01 	lds	r19, 0x01CE
 482:	23 2b       	or	r18, r19
 484:	41 f4       	brne	.+16     	; 0x496 <__stack+0x37>
 486:	20 91 62 00 	lds	r18, 0x0062
 48a:	30 91 63 00 	lds	r19, 0x0063
 48e:	30 93 ce 01 	sts	0x01CE, r19
 492:	20 93 cd 01 	sts	0x01CD, r18
 496:	20 91 60 00 	lds	r18, 0x0060
 49a:	30 91 61 00 	lds	r19, 0x0061
 49e:	21 15       	cp	r18, r1
 4a0:	31 05       	cpc	r19, r1
 4a2:	41 f4       	brne	.+16     	; 0x4b4 <__stack+0x55>
 4a4:	2d b7       	in	r18, 0x3d	; 61
 4a6:	3e b7       	in	r19, 0x3e	; 62
 4a8:	40 91 64 00 	lds	r20, 0x0064
 4ac:	50 91 65 00 	lds	r21, 0x0065
 4b0:	24 1b       	sub	r18, r20
 4b2:	35 0b       	sbc	r19, r21
 4b4:	e0 91 cd 01 	lds	r30, 0x01CD
 4b8:	f0 91 ce 01 	lds	r31, 0x01CE
 4bc:	e2 17       	cp	r30, r18
 4be:	f3 07       	cpc	r31, r19
 4c0:	a0 f4       	brcc	.+40     	; 0x4ea <__stack+0x8b>
 4c2:	2e 1b       	sub	r18, r30
 4c4:	3f 0b       	sbc	r19, r31
 4c6:	28 17       	cp	r18, r24
 4c8:	39 07       	cpc	r19, r25
 4ca:	78 f0       	brcs	.+30     	; 0x4ea <__stack+0x8b>
 4cc:	ac 01       	movw	r20, r24
 4ce:	4e 5f       	subi	r20, 0xFE	; 254
 4d0:	5f 4f       	sbci	r21, 0xFF	; 255
 4d2:	24 17       	cp	r18, r20
 4d4:	35 07       	cpc	r19, r21
 4d6:	48 f0       	brcs	.+18     	; 0x4ea <__stack+0x8b>
 4d8:	4e 0f       	add	r20, r30
 4da:	5f 1f       	adc	r21, r31
 4dc:	50 93 ce 01 	sts	0x01CE, r21
 4e0:	40 93 cd 01 	sts	0x01CD, r20
 4e4:	81 93       	st	Z+, r24
 4e6:	91 93       	st	Z+, r25
 4e8:	02 c0       	rjmp	.+4      	; 0x4ee <__stack+0x8f>
 4ea:	e0 e0       	ldi	r30, 0x00	; 0
 4ec:	f0 e0       	ldi	r31, 0x00	; 0
 4ee:	cf 01       	movw	r24, r30
 4f0:	df 91       	pop	r29
 4f2:	cf 91       	pop	r28
 4f4:	08 95       	ret

000004f6 <free>:
 4f6:	cf 93       	push	r28
 4f8:	df 93       	push	r29
 4fa:	00 97       	sbiw	r24, 0x00	; 0
 4fc:	09 f4       	brne	.+2      	; 0x500 <free+0xa>
 4fe:	87 c0       	rjmp	.+270    	; 0x60e <free+0x118>
 500:	fc 01       	movw	r30, r24
 502:	32 97       	sbiw	r30, 0x02	; 2
 504:	13 82       	std	Z+3, r1	; 0x03
 506:	12 82       	std	Z+2, r1	; 0x02
 508:	c0 91 cf 01 	lds	r28, 0x01CF
 50c:	d0 91 d0 01 	lds	r29, 0x01D0
 510:	20 97       	sbiw	r28, 0x00	; 0
 512:	81 f4       	brne	.+32     	; 0x534 <free+0x3e>
 514:	20 81       	ld	r18, Z
 516:	31 81       	ldd	r19, Z+1	; 0x01
 518:	28 0f       	add	r18, r24
 51a:	39 1f       	adc	r19, r25
 51c:	80 91 cd 01 	lds	r24, 0x01CD
 520:	90 91 ce 01 	lds	r25, 0x01CE
 524:	82 17       	cp	r24, r18
 526:	93 07       	cpc	r25, r19
 528:	79 f5       	brne	.+94     	; 0x588 <free+0x92>
 52a:	f0 93 ce 01 	sts	0x01CE, r31
 52e:	e0 93 cd 01 	sts	0x01CD, r30
 532:	6d c0       	rjmp	.+218    	; 0x60e <free+0x118>
 534:	de 01       	movw	r26, r28
 536:	20 e0       	ldi	r18, 0x00	; 0
 538:	30 e0       	ldi	r19, 0x00	; 0
 53a:	ae 17       	cp	r26, r30
 53c:	bf 07       	cpc	r27, r31
 53e:	50 f4       	brcc	.+20     	; 0x554 <free+0x5e>
 540:	12 96       	adiw	r26, 0x02	; 2
 542:	4d 91       	ld	r20, X+
 544:	5c 91       	ld	r21, X
 546:	13 97       	sbiw	r26, 0x03	; 3
 548:	9d 01       	movw	r18, r26
 54a:	41 15       	cp	r20, r1
 54c:	51 05       	cpc	r21, r1
 54e:	09 f1       	breq	.+66     	; 0x592 <free+0x9c>
 550:	da 01       	movw	r26, r20
 552:	f3 cf       	rjmp	.-26     	; 0x53a <free+0x44>
 554:	b3 83       	std	Z+3, r27	; 0x03
 556:	a2 83       	std	Z+2, r26	; 0x02
 558:	40 81       	ld	r20, Z
 55a:	51 81       	ldd	r21, Z+1	; 0x01
 55c:	84 0f       	add	r24, r20
 55e:	95 1f       	adc	r25, r21
 560:	8a 17       	cp	r24, r26
 562:	9b 07       	cpc	r25, r27
 564:	71 f4       	brne	.+28     	; 0x582 <free+0x8c>
 566:	8d 91       	ld	r24, X+
 568:	9c 91       	ld	r25, X
 56a:	11 97       	sbiw	r26, 0x01	; 1
 56c:	84 0f       	add	r24, r20
 56e:	95 1f       	adc	r25, r21
 570:	02 96       	adiw	r24, 0x02	; 2
 572:	91 83       	std	Z+1, r25	; 0x01
 574:	80 83       	st	Z, r24
 576:	12 96       	adiw	r26, 0x02	; 2
 578:	8d 91       	ld	r24, X+
 57a:	9c 91       	ld	r25, X
 57c:	13 97       	sbiw	r26, 0x03	; 3
 57e:	93 83       	std	Z+3, r25	; 0x03
 580:	82 83       	std	Z+2, r24	; 0x02
 582:	21 15       	cp	r18, r1
 584:	31 05       	cpc	r19, r1
 586:	29 f4       	brne	.+10     	; 0x592 <free+0x9c>
 588:	f0 93 d0 01 	sts	0x01D0, r31
 58c:	e0 93 cf 01 	sts	0x01CF, r30
 590:	3e c0       	rjmp	.+124    	; 0x60e <free+0x118>
 592:	d9 01       	movw	r26, r18
 594:	13 96       	adiw	r26, 0x03	; 3
 596:	fc 93       	st	X, r31
 598:	ee 93       	st	-X, r30
 59a:	12 97       	sbiw	r26, 0x02	; 2
 59c:	4d 91       	ld	r20, X+
 59e:	5d 91       	ld	r21, X+
 5a0:	a4 0f       	add	r26, r20
 5a2:	b5 1f       	adc	r27, r21
 5a4:	ea 17       	cp	r30, r26
 5a6:	fb 07       	cpc	r31, r27
 5a8:	79 f4       	brne	.+30     	; 0x5c8 <free+0xd2>
 5aa:	80 81       	ld	r24, Z
 5ac:	91 81       	ldd	r25, Z+1	; 0x01
 5ae:	84 0f       	add	r24, r20
 5b0:	95 1f       	adc	r25, r21
 5b2:	02 96       	adiw	r24, 0x02	; 2
 5b4:	d9 01       	movw	r26, r18
 5b6:	11 96       	adiw	r26, 0x01	; 1
 5b8:	9c 93       	st	X, r25
 5ba:	8e 93       	st	-X, r24
 5bc:	82 81       	ldd	r24, Z+2	; 0x02
 5be:	93 81       	ldd	r25, Z+3	; 0x03
 5c0:	13 96       	adiw	r26, 0x03	; 3
 5c2:	9c 93       	st	X, r25
 5c4:	8e 93       	st	-X, r24
 5c6:	12 97       	sbiw	r26, 0x02	; 2
 5c8:	e0 e0       	ldi	r30, 0x00	; 0
 5ca:	f0 e0       	ldi	r31, 0x00	; 0
 5cc:	8a 81       	ldd	r24, Y+2	; 0x02
 5ce:	9b 81       	ldd	r25, Y+3	; 0x03
 5d0:	00 97       	sbiw	r24, 0x00	; 0
 5d2:	19 f0       	breq	.+6      	; 0x5da <free+0xe4>
 5d4:	fe 01       	movw	r30, r28
 5d6:	ec 01       	movw	r28, r24
 5d8:	f9 cf       	rjmp	.-14     	; 0x5cc <free+0xd6>
 5da:	ce 01       	movw	r24, r28
 5dc:	02 96       	adiw	r24, 0x02	; 2
 5de:	28 81       	ld	r18, Y
 5e0:	39 81       	ldd	r19, Y+1	; 0x01
 5e2:	82 0f       	add	r24, r18
 5e4:	93 1f       	adc	r25, r19
 5e6:	20 91 cd 01 	lds	r18, 0x01CD
 5ea:	30 91 ce 01 	lds	r19, 0x01CE
 5ee:	28 17       	cp	r18, r24
 5f0:	39 07       	cpc	r19, r25
 5f2:	69 f4       	brne	.+26     	; 0x60e <free+0x118>
 5f4:	30 97       	sbiw	r30, 0x00	; 0
 5f6:	29 f4       	brne	.+10     	; 0x602 <free+0x10c>
 5f8:	10 92 d0 01 	sts	0x01D0, r1
 5fc:	10 92 cf 01 	sts	0x01CF, r1
 600:	02 c0       	rjmp	.+4      	; 0x606 <free+0x110>
 602:	13 82       	std	Z+3, r1	; 0x03
 604:	12 82       	std	Z+2, r1	; 0x02
 606:	d0 93 ce 01 	sts	0x01CE, r29
 60a:	c0 93 cd 01 	sts	0x01CD, r28
 60e:	df 91       	pop	r29
 610:	cf 91       	pop	r28
 612:	08 95       	ret

00000614 <_exit>:
 614:	f8 94       	cli

00000616 <__stop_program>:
 616:	ff cf       	rjmp	.-2      	; 0x616 <__stop_program>
